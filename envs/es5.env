let [%global] = { [] }

let [%Object] = {[]}

let [%getOwnPropertyDescriptorlambda] = func(this, args) {
  prim("print", "getOwnPropertyDescriptor")
}

let [%getOwnPropertyDescriptor] = { [#code : %getOwnPropertyDescriptorlambda,] }

let [%ObjectProto] = { [] 
  "getOwnPropertyDescriptor" : {#value %getOwnPropertyDescriptor, #writable false},
 }

let [%BooleanProto] = 
  { [#proto : %ObjectProto, #class : "Boolean", #value : false,]}

let [%NumberProto] = { [#proto : %ObjectProto, #class : "Number", #value : 0,]
  "NEGATIVE_INFINITY" : {#value -inf, #writable false},
  "POSITIVE_INFINITY" : {#value +inf, #writable false},
  "MAX_VALUE" : {#value 1.79769313486231571e+308, #writable false},
  "MIN_VALUE" : {#value 2.22507385850720138e-308, #writable false},
}

let [%ToBoolean] = func(x) {
  prim("prim->bool", x)
}

let [%instanceof] = func(o1, o2) {
    if(typeof o1 !== "object") {
        false
    }
    else {
      let (o2prototype = o2["prototype"])
      let (o1proto = prim("get-proto", o1))
      rec (instanceof = func(currproto) {
        if(currproto === null) {
           false
        }
        else {
          if(currproto === o1proto) {
            true
          }
          else {
            instanceof(prim("get-proto", currproto))
          }
        }
      })
      instanceof(o2prototype)
    }
}


let [%replacelambda] = func(this, args) {
    undefined
}

let [%replace] = { [#code : %replacelambda,] }

let [%StringProto] = { [#proto : %ObjectProto,] 
  "replace" : {#value %replace, #writable false}}

let [%StringIndices] = func(obj, s) {
  let (len = prim("strlen", s))
  rec (loop = func(i) {
    if (prim("<", i, len)) {
      obj[prim("prim->str", i) = prim("char-at", s, i)];
      loop(prim("+", i, 1))
    } else { undefined }
  })
  loop(0)
}

let [%ToObject] = func (o) {
    if (o === null) { throw o } else {
        label ret : 
        let (t = prim("surface-typeof", o))
        if (t === "object" || t === "function") {
           break ret o
        }
        else { null };
        if (t === "string") {
          let (obj = 
           {[#class: "String", 
             #extensible: true,
             #proto: %StringProto,
             #value: o,]
             "length" : {#value prim("strlen", o), #writable true}})
          %StringIndices(obj, o);
          break ret obj
        }
        else { null };
        if (t === "number") {
           break ret
           {[#class: "Number",
             #extensible: true,
             #proto: %NumberProto,
             #value: o,]}
        }
        else { null };
        if (t === "boolean") {
           break ret
           {[#class: "Boolean",
             #extensible: true,
             #proto: %BooleanProto,
             #value: o,]}
        }
        else { null };  
        if (t === "function") {
          break ret
          {[#class: "Function",
            #extensible: true,
            #proto: %BooleanProto,
            #value: o,]}
        }
        else { null };
        throw t
    }
}

let [%TETSlambda] = func(this, args) {
  "TypeError"
}

let [%TEToString] = 
  { [#code : %TETSlambda,] 
    "length" : {#value 0, #writable false} }

let [%TypeErrorProto] = { [#proto : %ObjectProto,] 
  "toString" : {#value %TEToString, #writable false} }

let [%TypeErrorConstructor] = func(this, args) {
  { [#proto : %TypeErrorProto,] }
}

let [%TypeErrorGlobalFuncObj] = 
  { [#code : %TypeErrorConstructor, #proto : %TypeErrorProto,] 
    "prototype" : {#value %TypeErrorProto, #writable false} }

{%TypeErrorProto["constructor" = %TypeErrorGlobalFuncObj]}

let [%ThrowTypeError] = {
    [ #code : func(this, args) {
        throw { [#proto : %TypeErrorProto,] }
      },]}

let [%ToPrimitiveNum] = func(obj) {
  let (check = func(o, str) {
    let (valueOf = o[str])
    if (prim("typeof", valueOf) === "function") {
        let (str = valueOf(o, {[]}))
        if (prim("primitive?", str)) {
            str
        } else { null }
    } else { null }
  })
  let (r1 = check(obj, "valueOf"))
  if (r1 !== null) { r1 } else {
    let (r2 = check(obj, "toString"))
    if (r2 !== null) { r2 } else {
      throw { [#proto : %TypeErrorProto,] }
    }
  }
}

let [%ToPrimitiveStr] = func(obj) {
    label ret :
    let (toString = obj["toString"])
    if (prim("typeof", toString) === "function") {
        let (str = toString(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    let (valueOf = obj["valueOf"])
    if (prim("typeof", valueOf) === "function") {
        let (str = valueOf(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    throw { [#proto : %TypeErrorProto,] }
}

let [%ToPrimitiveHint] = func(val, hint) {
    let (t = prim("typeof", val))
    if(t === "function" || t === "object") {
        if(hint === "string") {
            %ToPrimitiveStr(val)
        }
        else {
            %ToPrimitiveNum(val)
        }
    }
    else {
        val
    }
}

let [%ToPrimitive] = func(val) {
    // TODO exception for date objects
    %ToPrimitiveHint(val, "number")
}

let [%ToString] = func(val) {
    prim("prim->str", %ToPrimitiveHint(val, "string"))
}

let [%ToNumber] = func(val) {
    prim("prim->num", %ToPrimitiveHint(val, "number"))
}

let [%NumberConstructor] = func(this, args) {
  if (this === %global) {
    if (args["length"] === 0) { 0 } else { %ToNumber(args["0"]) }
  } else {
    let (v = if (args["0"] === undefined) { 0 } else { %ToNumber(args["0"]) })
    { [#proto : %NumberProto, #class : "Number", #value : v,] }
  }
}

let [%isNaNlambda] = func(this, args) {
    args["0"] !== args["0"]
}

// 11.9.3
let [%EqEq] = rec (eqeq = func(x1, x2) {
    label ret :
    let (t1 = prim("typeof", x1))
    let (t2 = prim("typeof", x2))
    if(t1 === t2) {
      if(t1 === "undefined") {
          break ret true
      }
      else {
          if(t1 === "null") {
              break ret true }
          else {
              if(t1 === "number") {
                  break ret (x1 === x2) }
              else {
                  if(t1 === "string") {
                      break ret (x1 === x2) }
                  else {
                      if(t1 === "object") {
                          break ret (x1 === x2) }
                      else {
                          throw "[env] Catastrophe---unknown type in ==" }
                  }}}}}
    else {

        if((x1 === undefined && x2 === null) ||
           (x1 === null && x2 === undefined)) {
            break ret true }
        else {
            if(t1 === "number" && t2 === "string") {
                break ret (x1 === prim("prim->num", x2)) }
            else {
                if(t1 === "string" && t2 === "number") {
                    break ret (prim("prim->num", x1) === x2) }
                else {
                    if(t1 === "boolean") {
                        break ret (eqeq(prim("prim->num", x1), x2)) }
                    else {
                        if (t2 === "boolean") {
                            break ret (eqeq(x1, prim("prim->num", x2))) }
                        else {
                            if((t1 === "string" || t1 === "number") &&
                               (t2 === "object")) {
                                break ret eqeq(x1, %ToPrimitive(x2)) }
                            else {
                                if((t2 === "string" || t2 === "number") &&
                                   (t1 === "object")) {
                                    break ret eqeq(%ToPrimitive(x1), x2) }
                                else {
                                    break ret false }
                            }}}}}}}}) eqeq
    

let [%isNaN] = { [#code : %isNaNlambda,] }

let [%printlambda] = func(o, s) {
    prim("print", %ToString(s["0"]))
}

let [%print] = { [#code : %printlambda,] }

let [%len] = func(list) {
    rec (inner_len = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                prim("+", 1, inner_len(prim("+", 1, iter)))
            }
            else { iter }
        })
    inner_len(0)
}

let [%slice] = func(list, min, max) {
    let (retObj = {[#extensible: true,]})
    rec (inner_slice = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                retObj[prim("prim->str", iter) = list[prim("prim->str", iter)] ];
                if(prim(">", iter, max)) { undefined }
                else { inner_slice(prim("+", iter, 1)) }
            }
            else { undefined }
        })
    inner_slice(min);
    retObj
}


let [isDataField] = func(obj, field) {
    ((obj[field<#value>] !== undefined) ||
     (obj[field<#writable>] !== undefined))
}

let [isAccessorField] = func(obj, field) {
    ((obj[field<#setter>] !== undefined) ||
     (obj[field<#getter>] !== undefined))
}

let [isGenericField] = func(obj, field) {
    (isDataField(obj, field) === false &&
     isAccessorField(obj, field) === false)
}

let [isDataDescriptor] = func(attr-obj) {
    (typeof (attr-obj["value"]) !== "undefined" ||
     typeof (attr-obj["writable"]) !== "undefined")
}

let [isAccessorDescriptor] = func(attr-obj) {
    (typeof (attr-obj["set"]) !== "undefined" ||
     typeof (attr-obj["get"]) !== "undefined")
}

let [isGenericDescriptor] = func(attr-obj) {
    (isAccessorDescriptor(attr-obj) === false &&
     isDataDescriptor(attr-obj) === false)
}

let [copy-when-defined] = func(obj1, obj2, s) {
    if(obj2[s] !== undefined) {
	obj1[s = obj2[s] ]
    }
    else { undefined }
}

let [copy-data-desc] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "writable");
    copy-when-defined(obj1, obj2, "value");
    obj1[delete "get"];
    obj1[delete "set"]

}

let [copy-access-desc] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "set");
    copy-when-defined(obj1, obj2, "get");
    obj1[delete "value"];
    obj1[delete "writable"]
}

/* 8.12.9 */
let [%defineOwnProperty] = func(obj, field, attr-obj) {
    let (t = typeof obj)
    if (t !== "object" && t !== "function") { throw "defineOwnProperty didn't get object" }
    //if (typeof obj !== "object") { throw "defineOwnProperty didn't get object" }
    else {
	let (fstr = %ToString(field))
	if (prim("hasOwnProperty", obj, fstr) === false) {
	    if (prim("is-extensible", obj)) {
		// Do this to open it up for the other properties (will set these last)
		obj[field<#configurable> = true];
		obj[field<#writable> = true];

		{if(isDataDescriptor(attr-obj)) {
		    obj[field<#value> = attr-obj["value"] ];
		    obj[field<#writable> = %ToBoolean(attr-obj["writable"]) ]
		}
		else if(isAccessorDescriptor(attr-obj)) {
		    obj[field<#getter> = attr-obj["get"] ];
		    obj[field<#setter> = attr-obj["set"] ]
		}
		 else { undefined }};

		obj[field<#enumerable> = %ToBoolean(attr-obj["enumerable"]) ];
		obj[field<#configurable> = %ToBoolean(attr-obj["configurable"]) ];
		true
	    }
	    else { throw type_error("(defineOwnProperty) Attempt to add a property to a non-extensible object.") }
	}
	else { /* it definitely has the property */
	    if (obj[field<#configurable>] === false) {
		if (attr-obj["configurable"] === true) {
		    throw type_error("escalating configurable from false to true")
		}
		else {
		    if(attr-obj["enumerable"] ===
		       (obj[field<#enumerable>] === false)) {
			throw type_error("(defineOwnPoperty) Can't change enumerable of a non-configurable property")
		    }
		}
	    };
	    
	    {if ((isDataDescriptor(current-prop)) !== (isDataDescriptor(attr-obj))) {
		if (obj[field<#configurable>] === false) {
		    throw type_error("(defineOwnProperty) Non-configurable property")
		}
		else {
		    if (isDataDescriptor(current)) {
			copy-data-desc(current-obj, attr-obj)
		    }
		    else {
			copy-access-desc(current-obj, attr-obj)
		    }
		}
	    }
	    else if ((isDataDescriptor(current-prop)) && 
		     (isDataDescriptor(attr-obj))) {
		if (current-prop["configurable"] === false) {
		    if (current-prop["writable"] === false) {
			if (attr-obj["writable"] === true) {
			    throw type_error("(defineOwnProperty) Cannot escalate writable from false to true.")
			}
			else {
			    if (attr-obj["value"] !== current-prop["value"]) {
				throw type_error("(defineOwnProperty) Cannot change a non-configurable value")
			    }
			    else { copy-data-desc(current-prop, attr-obj) }
			}
		    }
		    else { copy-data-desc(current-prop, attr-obj) }
		}
		else { copy-data-desc(current-prop, attr-obj) }
	    }
	    else {
		if (current-prop["configurable"] === false) {
		    if (current-prop["set"] !== attr-obj["set"] ||
			current-prop["get"] !== attr-obj["get"]) {
			throw type_error("(defineOwnProperty) Cannot change setter or getter of non-configurable property.")
		    }
		    else { copy-access-desc(current-prop, attr-obj) }
		}
		else { copy-access-desc(current-prop, attr-obj) }
	    }};

	    if(isDataDescriptor(current-prop)) {
		obj[field<#value> = current-prop["value"] ];
		obj[field<#writable> = current-prop["writable"] ]
	    }
	    else if(isAccessorDescriptor(current-prop)) {
		obj[field<#getter> = current-prop["get"] ];
		obj[field<#setter> = current-prop["set"] ]
	    }
	    else { undefined };
	    
	    obj[field<#enumerable> = current-prop["enumerable"] ];
	    obj[field<#configurable> = current-prop["configurable"] ];

	    true
	}
    }
}

{%defineOwnProperty(%NumberProto,
  "NaN",
  {[] "value" : {#value NaN, #writable true},
      "enumerable" : {#value false, #writable true},
      "configurable" : {#value false, #writable true},
      "writable" : {#value false, #writable true}}) }

let [%definePropertylambda] = func(this, args) {
    let (obj = args["0"])
    let (field = args["1"])
    let (propobj = args["2"])
    /* 8.10.5 checks */
    
    if ((typeof obj) !== "object") {
	throw type_error("defineProperty didn't get object")
    }
    else {
	let (attrobj = {[#extensible: true,]})
	let (enumerable = propobj["enumerable"])
	{if ((typeof enumerable) !== "undefined") {
	    attrobj["enumerable" = enumerable]
	}
	 else { attrobj }};

	let (configurable = propobj["configurable"])
	{if ((typeof configurable) !== "undefined") {
	    attrobj["configurable" = configurable]
	}
	 else { attrobj }};
	
	let (writable = propobj["writable"])
	{if ((typeof writable) !== "undefined") {
	    attrobj["writable" = writable]
	}
	 else { attrobj }};
	
	let (value = propobj["value"])
	{if ((typeof value) !== "undefined") {
	    attrobj["value" = value]
	}
	 else { attrobj }};
	
	let (get = propobj["get"])
	{if ((typeof get) !== "undefined" && 
	     (prim("surface-typeof", get) !== "function")) {
	    throw type_error("defineProperty given a non-function getter")
	}
	 else {
	     attrobj["get" = get]
	 }};
	
	let (set = propobj["set"])
	{if (typeof set !== "undefined" && 
	     (prim("surface-typeof", set) !== "function")) {
	    throw type_error("defineProperty given a non-function setter")
	}
	 else {
	     attrobj["set" = set]
	 }};

	// 8.10.5, step 9
	if ((isDataDescriptor(attrobj)) && 
            (isAccessorDescriptor(attrobj))) {
            throw "TypeError --- both accessor and data"
//	    throw type_error("The attributes given to defineProperty were inconsistent")
	}
	else {
	    %defineOwnProperty(obj, field, attrobj)
	}
    }	   
}

let [%defineProperty] = { [#code : %definePropertylambda,] }


 let [%ObjectConstructor] = func(this, args) {
  let (calledAsFunction = this === %global)
  let (hasArg = prim(">", args["length"], 0))
  let (notNull = prim("!", args["0"] === null))
  let (notUndefined = prim ("!", args["0"] === undefined))
  let (shouldReturnEarly =
    calledAsFunction && hasArg && notNull && notUndefined)
  let (defaultRtn = { [#proto : %ObjectProto,] })
  if (shouldReturnEarly) {
    %ToObject(args["0"])
  } else {
    if (hasArg) {
      let (argtype = prim("typeof", args["0"]))
      let (isArgObject = argtype === "object" || argtype === "function")
      let (isArgSomething = argtype === "boolean" ||
        argtype === "string" || argtype === "number")
      if (isArgObject) { args["0"] } else {
        if (isArgSomething) { %ToObject(args["0"]) } else { defaultRtn }
      }
    } else {
      defaultRtn
    }
  }
}

let [%calllambda] = func(this, args) {
    this(args["0"], %slice(args, 1, %len(args)))
}

let [%call] = { [#code : %calllambda,] }

let [%functionToStringlambda] = func(this, args) {
  "function ToString"
}

let [%functionToString] = 
{ [#code : %functionToStringlambda,] 
  "length" : {#value 0, #writable false} }

let [%FunctionProto] = { [#proto: %ObjectProto, #class : "Function",]
  "toString" : {#value %functionToString, #writable true},
  "call" : {#value %call, #writable false} }

let [%NumberGlobalFuncObj] = 
  { [#code : %NumberConstructor, #proto : %FunctionProto,]
    "prototype" : {#value %NumberProto, #writable false},
    "MAX_VALUE" : {#value 1.79769313486231571e+308, #writable false},
    "MIN_VALUE" : {#value 5.0e-324, #writable false},
    "NaN" : {#value NaN, #writable false},
    "NEGATIVE_INFINITY" : {#value -inf, #writable false},
    "POSITIVE_INFINITY" : {#value +inf, #writable false},
    "length" : {#value 1, #writable false}}

{%NumberProto["constructor" = %NumberGlobalFuncObj]}

let [%stringToStringlambda] = func(this, args) {
  prim("get-primval", this)
}

let [%stringToString] = 
  { [#code : %stringToStringlambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false} }

{%defineOwnProperty(%StringProto,
  "toString",
  {[] "value" : {#value %stringToString, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%StringConstructor] = func(this, args) {
  let (S = if (args["length"] === 0) { "" } else { %ToString(args["0"]) })
  if (this === %global) {
    // Called as function
    S
  } else {
    let (obj = 
      {[#proto : %StringProto, #value : S, #class : "String",]
        "length" : {#value prim("strlen", S), #writable true}})
    %StringIndices(obj, S);
    obj
  }
}

let [%StringGlobalFuncObj] = 
  { [#code : %StringConstructor, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false} }

let [%BooleanConstructor] = func(this, args) {
  let (b = %ToBoolean(args["0"]))
  if (this === %global) {
    b
  } else {
    {[#proto : %BooleanProto, #class : "Boolean", #value : b,]}
  }
}

let [%booleanToStringlambda] = func(this, args) {
  let (t = prim("typeof", this))
  let (b = if (t === "boolean") { this } else {
    if (t === "object") {
      if (prim("get-class", this) === "Boolean") {
        prim("get-primval", this)
      } else { throw {[#proto : %TypeErrorProto,]}}
    } else { throw {[#proto : %TypeErrorProto,]} }
  })
  if (b) { "true" } else { "false" }
}

let [%booleanToString] = 
  { [#code : %booleanToStringlambda,] 
    "length" : {#value 0, #writable false} }

{%defineOwnProperty(%BooleanProto,
  "toString",
  {[] "value" : {#value %booleanToString, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%BooleanGlobalFuncObj] = { [#code : %BooleanConstructor, #proto : %FunctionProto,] }

{%BooleanProto["constructor" = %BooleanGlobalFuncObj];
 %BooleanGlobalFuncObj["length" = 1]}

{%defineOwnProperty(%BooleanGlobalFuncObj,
  "prototype",
  {[] "value" : {#value %BooleanProto, #writable true},
      "configurable" : {#value false, #writable true}}) }

{%StringProto["constructor" = %StringGlobalFuncObj];
 %StringGlobalFuncObj["prototype" = %StringProto];
 %StringGlobalFuncObj["prototype"<#enumerable> = false];
 %StringGlobalFuncObj["prototype"<#writable> = false];
 %StringGlobalFuncObj["prototype"<#configurable> = false] }

 let [%ObjectGlobalFuncObj] = 
  { [#code : %ObjectConstructor, #proto : %FunctionProto,] 
    "prototype" : {#value %ObjectProto, #writable false},
    "length" : {#value 1, #writable false},
  }

 {%ObjectProto["constructor" = %ObjectGlobalFuncObj];
  %ObjectProto["constructor"<#enumerable> = false]}

// TODO: implement
let [%freezelambda] = func(this, args) {
  undefined
}

let [%freeze] = {[#code : %freezelambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%ObjectGlobalFuncObj,
  "freeze",
  {[] "value" : {#value %freeze, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%FunctionConstructor] = func(this, args) {
  let (argCount = args["length"])
  rec (formArgString = func(n, result) {
    if (n === argCount) {
      result
    } else {
      let (currentArg = %ToString(args[prim("prim->str", n)]))
      let (next = 
        if (n === prim("-", argCount, 1)) { 
          prim("+", result, currentArg)
        } else {
          prim("+", prim("+", result, currentArg), ",")
        })
      formArgString(prim("+", n, 1), next)
    }
  })
  let (body = 
    if (argCount === 0) { "" } else {
      args[prim("prim->str", prim("-", argCount, 1))]
    })
  let (P = if (argCount === 0 || argCount === 1) { "" }
    else { formArgString(0, "") })
  let (bodyF = func(this, args){ @eval(body) })
  { [#code : bodyF, #proto : %FunctionProto,] 
    "length" : {#value argCount, #writable false} }
}

let [%FunctionGlobalFuncObj] = 
  { [#code : %FunctionConstructor, #proto : %FunctionProto,] 
    "prototype" : {#value %FunctionProto, #writable false},
    "length" : {#value 0, #writable false}
  }

{%FunctionProto["constructor" = %FunctionGlobalFuncObj];
 %FunctionProto["constructor"<#enumerable> = false] }

let [%objectToStringlambda] = func(this, args) {
  label ret:
  if (this === undefined) {
    break ret "[object Undefined]"
  } else { undefined };

  if (this === null) {
    break ret "[object Null]"
  } else { undefined };

  let (O = %ToObject(this))
  let (class = prim("get-class", O))
  break ret prim("string+", "[object ", prim("string+", class, "]"))
}

let [%objectToString] = 
  { [#code : %objectToStringlambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false} }

let [%propEnumlambda] = func(this, args) {
  let (getOwnProperty = func(o, f) {
    if (prim("hasOwnProperty", o, f)) { o[f] } else { undefined }})
  if (args["0"] === undefined) { false } else {
  let (P = %ToString(args["0"]))
  let (O = %ToObject(this))
  let (desc = getOwnProperty(O, P))
  if (desc === undefined) {
    false
  } else { 
    O[P<#enumerable>] 
  }}
}

let [%propertyIsEnumerable] = 
  {[#code : %propEnumlambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false} }

let [%toLocaleStringlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (toString = O["toString"])
  if (prim("get-code", toString) === null) {
    throw { [#proto : %TypeErrorProto,] }
  } else {
    toString(O, {[]})
  }
}

let [%toLocaleString] = 
  { [#code : %toLocaleStringlambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false} }

let [%valueOflambda] = func(this, args) {
  %ToObject(this)
}

let [%valueOf] = 
  { [#code : %valueOflambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false}
  }


let [%hasOwnPropertylambda] = func(this, args) {
    if(prim("hasOwnProperty", this, args["0"])) {
      true
    }
    else {
      false
    }
}

let [%hasOwnProperty] = 
  { [#code : %hasOwnPropertylambda, #proto : %FunctionProto,] 
    "length" : {#value 1, #writable false}
  }


let [%IsPrototypeOflambda] = func(this, args) {
    rec (searchChain = func(o, v) {
      let (vproto = prim("get-proto", v))
      if (vproto === null) {
        false
      } else {
        if (o === vproto) {
          true
        } else {
          searchChain(o, vproto) 
        }
      }
    })
    let (vtype = prim("typeof", args["0"]))
    if (prim("!", vtype === "object") && prim("!", vtype === "function")) {
      false
    } else {
      let (O = %ToObject(this))
      searchChain(O, args["0"])
    }
}

let [%isPrototypeOf] = 
  { [#code : %IsPrototypeOflambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false}
  }

{ %ObjectProto["toString" = %objectToString];
  %ObjectProto["toString"<#writable> = true];
  %ObjectProto["toString"<#enumerable> = false];

  %ObjectProto["toLocaleString" = %toLocaleString];
  %ObjectProto["toLocaleString"<#writable> = false];
  %ObjectProto["toLocaleString"<#enumerable> = false];

  %ObjectProto["valueOf" = %valueOf];
  %ObjectProto["valueOf"<#writable> = true];
  %ObjectProto["valueOf"<#enumerable> = false];

  %ObjectProto["hasOwnProperty" = %hasOwnProperty];
  %ObjectProto["hasOwnProperty"<#writable> = false];
  %ObjectProto["hasOwnProperty"<#enumerable> = false];

  %ObjectProto["isPrototypeOf" = %isPrototypeOf];
  %ObjectProto["isPrototypeOf"<#writable> = false];
  %ObjectProto["isPrototypeOf"<#enumerable> = false]
}

let [%RETSlambda] = func(this, args) {
  "RangeError"
}

let [%REToString] = 
  { [#code : %TETSlambda,] 
    "length" : {#value 0, #writable false} }

let [%RangeErrorProto] = { [#proto : %ObjectProto,] 
  "toString" : {#value %REToString, #writable false} }

let [%RangeErrorConstructor] = func(this, args) {
  { [#proto : %TypeErrorProto,] }
}

let [%RangeErrorGlobalFuncObj] = 
  { [#code : %RangeErrorConstructor, #proto : %RangeErrorProto,] 
    "prototype" : {#value %RangeErrorProto, #writable false} }

{%RangeErrorProto["constructor" = %RangeErrorGlobalFuncObj]}

let [%ArrayProto] = { [#proto : %ObjectProto, #class : "Array",]
  "length" : {#value 0, #writable true} }

let [%ToUint] = func(n, limit) {
  let (number = %ToNumber(n))
  if (number !== number || number === 0 || number === +inf || number === -inf) { 
    0 
  } else {
    let (sign = if (prim("<", number ,0)) { prim("-", 0, 1) } else { 1 })
    let (posInt = prim("*", sign, prim("floor", prim("abs", number))))
    if (prim("<", sign, 0)) {
      let (close = prim("%", posInt, limit))
      prim("+", close, limit)
    } else { 
      prim("%", posInt, limit)
    }
  }
}

let [%ToUint32] = func(n) {
  %ToUint(n, 4294967296.0)
}

let [%ToUint16] = func(n) {
  %ToUint(n, 65536.0)
}

let [%fromcclambda] = func(this, args) {
  if (args["length"] === 0) {
    ""
  } else {
    let (end = args["length"])
    rec (loop = func(i, soFar) {
      if (prim("<", i, end)) {
        let (char = prim("ascii_ntoc", %ToUint16(args[prim("prim->str", i)])))
        let (next = prim("string+", soFar, char))
        loop(prim("+", i, 1), next)
      } else { soFar }
    })
    loop(0, "")
  }
}

let [%fromCharCode] = 
  {[#code : %fromcclambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false}}

{%defineOwnProperty(%StringGlobalFuncObj,
  "fromCharCode",
  {[] "value" : {#value %fromCharCode, #writable true},
      "configurable" : {#value true, #writable true},
      "writable" : {#value true, #writable true}}) }

let [%joinlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (sep = if (args["0"] === undefined) { "," } 
    else { %ToString(args["0"]) })
  label ret:
  if (len === 0) {
    break ret ""
  } else { null };
  rec (loop = func(k, R) {
    if (prim(">=", k, len)) {
      R
    } else {
      let (S = prim("string+", R, sep))
      let (element = O[%ToString(k)])
      let (next =
        if (element === null || element === undefined) { "" }
        else { %ToString(element) })
      loop(prim("+", k, 1), prim("string+", S, next)) 
    }
  })
  let (start = if (O["0"] === undefined || O["0"] === null) { "" }
    else { %ToString(O["0"]) })
  break ret loop(1, start)
}

let [%join] = { [#code : %joinlambda, #proto : %FunctionProto,] }

{%defineOwnProperty(%join, 
    "length", 
    {[] "value" : {#value 1, #writable true}, 
        "configurable" : {#value false, #writable true},
        "enumerable" : {#value false, #writable true}})}

let [%poplambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  if (len === 0) {
    O["length" = 0];
    undefined
  } else {
    let (indx = %ToString(prim("-", len, 1)))
    let (element = O[indx])
    O[delete indx];
    O["length" = %ToNumber(indx)];
    element
  }
}

let [%pop] = { [#code : %poplambda, #proto : %FunctionProto,] }

{%defineOwnProperty(%pop,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}})}

{%defineOwnProperty(%ArrayProto,
  "pop",
  {[] "value" : {#value %pop, #writable true},
      "configurable" : {#value true, #writable true}})}

let [%pushlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  rec (loop = func(i, n) {
    if (prim("<", i, args["length"])) {
      let (ii = prim("prim->str", i))
      O[%ToString(n) = args[ii] ];
      loop(prim("+", i, 1), prim("+", n, 1))
    } else { n }
  })
  let (result = loop(0, len))
  if (prim("get-class", O) === "Array") {
    let (c1 = %ToNumber(result))
    let (c2 = %ToUint32(result))
    if (c1 === c2) {
      O["length" = result]
    } else {
      throw {[#proto : %RangeErrorProto,]}
    }
  } else {
    O["length" = result]
  }
}

let [%push] = {[#code : %pushlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%push,
  "length",
  {[] "value" : {#value 1, #writable true},
      "configurable" : {#value false, #writable true}})}

{%defineOwnProperty(%ArrayProto,
  "push",
  {[] "value" : {#value %push, #writable true},
      "configurable" : {#value true, #writable true}})}

let [%reverselambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (middle = prim("floor", prim("/", len, 2)))
  rec (loop = func(lower) {
    if (lower !== middle) {
      label ret:
      let (upper = prim("-", prim("-", len, lower), 1))
      let (upperP = %ToString(upper))
      let (lowerP = %ToString(lower))
      let (lowerValue = O[lowerP])
      let (upperValue = O[upperP])
      let (lowerExists = prim("hasProperty", O, lowerP))
      let (upperExists = prim("hasProperty", O, upperP))

      if (lowerExists && upperExists) {
        O[lowerP = upperValue];
        O[upperP = lowerValue];
        break ret loop(prim("+", lower, 1))
      } else { null };

      if (upperExists) {
        O[lowerP = upperValue];
        O[delete upperP];
        break ret loop(prim("+", lower, 1))
      } else { null };

      if (lowerExists) {
        O[delete lowerP];
        O[upperP = lowerValue];
        break ret loop(prim("+", lower, 1))
      } else { null };

      break ret loop(prim("+", lower, 1))
    }
  })
  loop(0);
  O
}

let [%reverse] = {[#code : %reverselambda, #proto : %FunctionProto,]}

{ %defineOwnProperty(%reverse,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
  "reverse",
  {[] "value" : {#value %reverse, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%shiftlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  if (len === 0) {
    O["length" = 0];
    undefined
  } else { 
    let (first = O["0"])
    rec (loop = func(k) {
      label ret:
      if (prim(">=", k, len)) {
        break ret undefined
      } else { null };

      let (from = %ToString(k))
      let (to = %ToString(prim("-", k, 1)))
      let (fromPresent = prim("hasProperty", O, from))
      if (fromPresent) {
        let (fromVal = O[from])
        O[to = fromVal];
        break ret loop(prim("+", k, 1))
      } else {
        O[delete to];
        break ret loop(prim("+", k, 1))
      }
    })
    loop(1);
    let (newLen = prim("-", len, 1))
    O[delete %ToString(newLen)];
    O["length" = newLen];
    first
  }
}

let [%shift] = {[#code : %shiftlambda, #proto : %FunctionProto,]}

{ %defineOwnProperty(%shift,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
  "shift",
  {[] "value" : {#value %shift, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%arrayToStringlambda] = func(this, args) {
  let (array = %ToObject(this))
  let (thefunc = array["join"])
  let (ffunc = 
  if (prim("!", prim("typeof", thefunc) === "object") &&
      prim("!", prim("typeof", thefunc) === "function")) {
    %objectToStringlambda
  } else {
    if (prim("get-code", thefunc) === null) {
      %objectToStringlambda
    } else { thefunc }
  })
  ffunc(array, {[]})
}

let [%arrayToString] = 
  { [#code : %arrayToStringlambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false} }

{ %defineOwnProperty(%ArrayProto, 
    "toString", 
    {[] "value" : {#value %arrayToString, #writable true}, 
        "writable" : {#value true, #writable true},
        "configurable" : {#value true, #writable true}});
  %defineOwnProperty(%ArrayProto,
    "join",
    {[] "value" : {#value %join, #writable true},
        "configurable" : {#value true, #writable true}}) }

let [%arrayTLSlambda] = func(this, args) {
  let (isCallable = func(o) {
    label ret:
    if (prim("!", prim("typeof", o) === "object") &&
        prim("!", prim("typeof", o) === "function")) {
      break ret false 
    } else { null };
    if (prim("get-code", o) === null) {
      break ret false
    } else { null };
    break ret true
  })
  let (array = %ToObject(this))
  let (arrayLen = array["length"])
  let (len = %ToUint32(arrayLen))
  let (separator = " ")
  label ret:
  if (len === 0) {
    break ret ""
  } else { null };
  let (firstElement = array["0"])
  let (R = if (firstElement === null || firstElement === undefined) { "" } else {
    let (elementObj = %ToObject(firstElement))
    let (funcc = elementObj["toLocaleString"])
    if (prim("!", isCallable(funcc))) {
      throw {[#proto : %TypeErrorProto,]}
    } else { null };
    funcc(elementObj, {[]}) })
    rec (inner = func(k, r) {
      if (prim(">=", k, len)) {
        r
      } else {
        let (S = prim("string+", prim("prim->str", r), separator))
        let (nextElement = array[prim("prim->str", k)])
        let (toAppend = if (nextElement === null ||
          nextElement === undefined) { "" } else {
          let (elementObj = %ToObject(nextElement))
          let (funcc = elementObj["toLocaleString"])
          if (prim("!", isCallable(funcc))) {
            throw {[#proto : %TypeErrorProto,]}
          } else { null };
          funcc(elementObj, {[]}) })
          inner(prim("+", k, 1), 
            prim("string+", prim("prim->str", r),
            prim("prim->str", toAppend)))
      }
    })
    break ret inner(1, R)
}

let [%arrayToLocaleString] = 
  { [#code : %arrayTLSlambda, #proto : %FunctionProto,]
    "length" : {#value 0, #writable false} }

{ %defineOwnProperty(%ArrayProto, 
    "toLocaleString", 
    {[] "value" : {#value %arrayToLocaleString, #writable true}, 
        "configurable" : {#value true, #writable true}}) }

let [%ArrayConstructor] = func(this, args) {
  label ret:
  if (prim(">=", args["length"], 2)) {
    let (rtnobj = 
      {[#proto : %ArrayProto, #class : "Array",] 
        "length" : {#value 0, #writable true}, })
    rec (init = func(n) {
      rtnobj[ prim("prim->str", n) = args[prim("prim->str", n)] ];
      if (prim(">", n, 0)) {
        init(prim("-", n, 1))
      }
    })
    init(args["length"]);
    rtnobj["length" = args["length"] ];
    break ret rtnobj
  } else { null };
  let (c1 = prim("typeof", args["0"]) === "number")
  let (c2 = if (c1) { %ToUint32(args["0"]) !== args["0"] } else { false })
  if (c2) {
    throw {[#proto : %RangeErrorProto,]}
  } else {
    if (c1) {
      break ret { [#proto : %ArrayProto, #class : "Array",]
        "length" : {#value %ToUint32(args["0"]), #writable true} }
    } else {
      break ret {[#proto : %ArrayProto, #class : "Array",]
        "length" : {#value args["length"], #writable true},
        "0" : {#value args["0"], #writable true} }
    }
  }
}

let [%concatLambda] = func(this, args) {
  let (O = %ToObject(this))
  let (emptyobj = {[]})
  let (A = %ArrayConstructor(emptyobj, emptyobj))
  rec (procElt = func(obj, elt, n) {
    let (procNormalElt = func(nelt, k) {
      obj[prim("prim->str", k) = nelt];
      prim("+", k, 1)
    })
    rec (procArrayElt = func(arr, fromIndex, toIndex) {
      if (arr[prim("prim->str", fromIndex)] === undefined) {
        toIndex
      } else {
        obj[prim("prim->str", toIndex) = arr[prim("prim->str", fromIndex)] ];
        procArrayElt(arr, prim("+", fromIndex, 1), prim("+", toIndex, 1))
      }
    })
    if (prim("typeof", elt) === "object") {
      if (prim("get-class", elt) === "Array") {
        procArrayElt(elt, 0, n)
      } else {
        procNormalElt(elt, n)
      }
    } else {
      procNormalElt(elt, n)
    }
  })
  rec (procAllElts = func(from, fromIndex, toIndex) {
    if (from[prim("prim->str", fromIndex)] !== undefined) {
      let (nextI = procElt(A, from[prim("prim->str", fromIndex)], toIndex))
      procAllElts(from, prim("+", fromIndex, 1), nextI)
    } else { toIndex }
  })
  let (halftime = if (prim("get-class", O) === "Array") {
    procAllElts(O, 0, 0) } else { A["0" = O]; 1 })
  let (end = procAllElts(args, 0, halftime))
  A["length" = end];
  A
}

let [%concat] = 
  { [#code : %concatLambda, #proto : %FunctionProto,] }

{ %defineOwnProperty(%concat,
    "length",
    {[] "value" : {#value 1, #writable true},
        "enumerable" : {#value false, #writable true}})}

{ %defineOwnProperty(%ArrayProto,
    "concat",
    {[] "value" : {#value %concat, #writable true}})}

let [%sortlambda] = func(this, args) {
  let (obj = %ToObject(this))
  let (sortCompare = func(j, k) {
    let (jString = %ToString(j))
    let (kString = %ToString(k))

    let (hasj = prim("hasProperty", obj, jString))
    let (hask = prim("hasProperty", obj, kString))
    label ret:
    if (hasj === false && hask === false) {
      break ret 0
    } else { null };

    if (hasj === false) {
      break ret 1
    } else { null };

    if (hask === false) {
      break ret prim("-", 0, 1)
    } else { null };

    let (x = obj[jString])
    let (y = obj[kString])
    if (x === undefined && y === undefined) {
      break ret 0
    } else { null };

    if (x === undefined) {
      break ret 1
    } else { null };

    if (y === undefined) {
      break ret prim("-", 0, 1)
    } else { null };

    if (args["0"] !== undefined) {
      if (prim("typeof", args["0"]) !== "function") {
        throw {[#proto : %TypeErrorProto,]}
      } else { null };

      break ret args["0"](undefined, 
        {[] "0" : {#value x, #writable true},
            "1" : {#value y, #writable true}})
    } else { null };

    let (xString = %ToString(x))
    let (yString = %ToString(y))

    if (prim("string<", xString, yString)) {
      break ret prim("-", 0, 1)
    } else { null };

    if (prim("string<", yString, xString)) {
      break ret 1
    } else { null };

    break ret 0
  })

  let (insert = func(elt, before) {
    rec (insertAndShift = func(prior, i) {
      let (indx = prim("prim->str", i))
      let (next = obj[indx])
      obj[indx = prior];
      if (prim("<", i, before)) {
        insertAndShift(next, prim("+", i, 1))
      } else { undefined }
    })

    rec (loop = func(currIndex) {
      if (currIndex === before) {
        // elt can stay where it was
        undefined
      } else {
        let (indx = prim("prim->str", currIndex))
        //let (result = sortCompare(obj[indx], elt))
        let (result = sortCompare(currIndex, before))
        //let (result = if (prim("<", obj[indx], elt)) { 0 } else { 1 })
        if (result === 1) {
          let (old = obj[indx])
          obj[indx = elt];
          insertAndShift(old, prim("+", currIndex, 1))
        } else {
          loop(prim("+", currIndex, 1))
        }
      }
    })

    loop(0)
  })

  let (len = obj["length"])
  rec (isort = func(i) {
    if (prim("<", i, len)) {
      insert(obj[prim("prim->str", i)], i);
      isort(prim("+", i, 1))
    } else { undefined }
  })

  isort(1)
}

let [%sort] = { [#code : %sortlambda, #proto : %FunctionProto,] }

{%defineOwnProperty(%sort,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "sort",
  {[] "value" : {#value %sort, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%ArrayGlobalFuncObj] = 
  { [#code : %ArrayConstructor, #proto : %FunctionProto, #class : "Function",] 
    "prototype" : {#value %ArrayProto, #writable false} }

{ %ArrayGlobalFuncObj["length" = 1];
  %ArrayGlobalFuncObj["length"<#enumerable> = false];
  %ArrayGlobalFuncObj["length"<#configurable> = false];
  %defineOwnProperty(%ArrayProto,
      "constructor",
      {[] "value" : {#value %ArrayGlobalFuncObj, #writable true},
          "configurable" : {#value true, #writable true},
          "enumerable" : {#value false, #writable true}}) }

let [%getCurrentUTC] = func() { 0 } // TODO: implement

let [%parse] = func(v) { 0 } // TODO: implement

let [%TimeClip] = func(v) { 0 } // TODO: implement

let [%ToInteger] = func(i) { 
  label ret:
  let (number = %ToNumber(i))
  if (number !== number) {
    break ret 0
  } else { null };
  if (number === 0 || number === +inf || number === -inf) { 
    break ret number
  } else { null };
  // Why 0 - 1? No negative number literals (yet)
  let (sign = if (prim("<", number, 0)) { prim("-", 0, 1) } else { 1 })
  let (a = prim("abs", number))
  let (f = prim("floor", a))
  let (r = prim("*", sign, f))
  break ret r
}

let [%CheckObjectCoercible] = func(o) {
  if (o === undefined || o === null) {
    throw {[#proto : %TypeErrorProto,]}
  } else { undefined }
}

let [%charatlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (position = %ToInteger(args["0"]))
  let (size = prim("strlen", S))
  if (prim("<", position, 0) || prim(">=", position, size)) {
    ""
  } else { 
    prim("char-at", S, position)
  }
}

let [%charat] = {[#code : %charatlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%charat,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "charAt",
  {[] "value" : {#value %charat, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%charcodeatlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (position = %ToInteger(args["0"]))
  let (size = prim("strlen", S))
  if (prim("<", position, 0) || prim(">=", position, size)) {
    NaN
  } else { 
    prim("ascii_cton", prim("char-at", S, position))
  }
}

let [%charcodeat] = {[#code : %charcodeatlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%charcodeat,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "charCodeAt",
  {[] "value" : {#value %charcodeat, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%strconcatlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (end = args["length"])
  rec (loop = func(i, soFar) {
    if (prim("<", i, end)) {
      let (next = %ToString(args[prim("prim->str", i)]))
      loop(prim("+", i, 1), prim("string+", soFar, next))
    } else { soFar }
  })
  loop(0, S)
}

let [%strconcat] = {[#code : %strconcatlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%strconcat,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "concat",
  {[] "value" : {#value %strconcat, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%min] = func(a, b) {
  if (prim("<=", a, b)) { a } else { b }
}
let [%max] = func(a, b) {
  if (prim("<=", a, b)) { b } else { a }
}

let [%substringlambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (len = prim("strlen", S))
  let (intStart = %ToInteger(args["0"]))
  let (intEnd =
    let (end = args["1"])
    if (end === undefined) { len } else { %ToInteger(end) })
  let (finalStart = %min(%max(intStart, 0), len))
  let (finalEnd = %min(%max(intEnd, 0), len))
  let (from = %min(finalStart, finalEnd))
  let (to = %max(finalStart, finalEnd))
  rec (loop = func(i, soFar) {
    if (prim("<", i, to)) {
      loop(prim("+", i, 1), prim("string+", soFar, prim("char-at", S, i)))
    } else { soFar }
  })
  loop(from, "")
}

let [%substring] = {[#code : %substringlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%substring,
  "length",
  {[] "value" : {#value 2, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%StringProto,
  "substring",
  {[] "value" : {#value %substring, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%splicelambda] = func(this, args) {
  let (start = args["0"])
  let (deleteCount = args["1"])

  let (O = %ToObject(this))
  let (emptyobj = {[]})
  let (A = 
    {[#proto : %ArrayProto, #class : "Array",] 
        "length" : {#value 0, #writable true}})
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (relativeStart = %ToInteger(start))
  let (actualStart = 
    if (prim("<", relativeStart, 0)) {
      %max(prim("+", len, relativeStart), 0)
    } else {
      %min(relativeStart, len)
    })
  let (actualDeleteCount =
    %min(%max(%ToInteger(deleteCount), 0), prim("-", len, actualStart)))

  rec (writeToALoop = func(k) {
    if (prim("<", k, actualDeleteCount)) {
      let (from = %ToString(prim("+", actualStart, k)))
      if (prim("hasProperty", O, from)) {
        let (fromValue = O[from])
        %defineOwnProperty(A,
          %ToString(k),
          {[] "value" : {#value fromValue, #writable true},
              "writable" : {#value true, #writable true},
              "enumerable" : {#value true, #writable true},
              "configurable" : {#value true, #writable true}});
        A["length" = prim("+", A["length"], 1)];
        writeToALoop(prim("+", k, 1))
      } else {
        writeToALoop(prim("+", k, 1))
      }
    } else { undefined }
  })
  writeToALoop(0);

  let (itemCount = prim("-", args["length"], 2))
  let (step1 = func() {
    if (prim("<", itemCount, actualDeleteCount)) {
      let (end = prim("-", len, actualDeleteCount))
      rec (writeToOLoop = func(k) {
        if (prim("<", k, end)) {
          let (from = %ToString(prim("+", k, actualDeleteCount)))
          let (to = %ToString(prim("+", k, itemCount)))
          if (prim("hasProperty", O, from)) {
            O[to = O[from] ];
            writeToOLoop(prim("+", k, 1))
          } else { 
            O[delete to];
            writeToOLoop(prim("+", k, 1))
          }
        } else { undefined }
      })
      writeToOLoop(actualStart);

      let (delLimit = prim("+", prim("-", len, actualDeleteCount), itemCount))
      rec (deleteloop = func(k) {
        if (prim(">", k, delLimit)) {
          let (next = prim("-", k, 1))
          O[delete %ToString(next)];
          deleteloop(next)
        } else { undefined }
      })
      deleteloop(len)
    } else { null }
  })
  step1();

  let (step2 = func() {
    if (prim(">", itemCount, actualDeleteCount)) {
      rec (writeToOLoop = func(k) {
        if (prim(">", k, actualStart)) {
          let (from = %ToString(prim("+", k, prim("-", actualDeleteCount, 1))))
          let (to = %ToString(prim("+", k, prim("-", itemCount, 1))))
          if (prim("hasProperty", O, from)) {
            O[to = O[from] ];
            writeToOLoop(prim("-", k, 1))
          } else { 
            O[delete to];
            writeToOLoop(prim("-", k, 1))
          }
        } else { undefined }
      })

      writeToOLoop(prim("-", len, actualDeleteCount))
    } else {
      undefined
    }
  })
  step2();

  let (outerEnd = args["length"])
  rec(outerloop = func(k, argsIndex) {
    if (prim("<", argsIndex, outerEnd)) {
      O[%ToString(k) = args[prim("prim->str", argsIndex)] ];
      outerloop(prim("+", k, 1), prim("+", argsIndex, 1))
    } else { undefined }
  })
  outerloop(actualStart, 2);
  O["length" = prim("+", prim("-", len, actualDeleteCount), itemCount)];
  A
}

let [%splice] = {[#code : %splicelambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%splice,
  "length",
  {[] "value" : {#value 2, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "splice",
  {[] "value" : {#value %splice, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%unshiftlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (argCount = args["length"])

  rec (Oloop = func(k) {
    if (prim(">", k, 0)) {
      let (from = %ToString(prim("-", k, 1)))
      let (to = %ToString(prim("+", k, prim("-", argCount, 1))))
      if (prim("hasProperty", O, from)) {
        O[to = O[from] ];
        Oloop(prim("-", k, 1))
      } else { 
        O[delete to];
        Oloop(prim("-", k, 1))
      }
    } else { undefined }
  })
  Oloop(len);

  let (end = args["length"])
  rec (argsLoop = func(argsIndex, j) {
    if (prim("<", argsIndex, end)) {
      O[%ToString(j) = args[prim("prim->str", argsIndex)] ];
      argsLoop(prim("+", argsIndex, 1), prim("+", j, 1))
    } else { undefined }
  })
  argsLoop(0, 0);

  let (finalLen = prim("+", len, argCount))
  O["length" = finalLen];
  finalLen
}

let [%unshift] = {[#code : %unshiftlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%unshift,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "unshift",
  {[] "value" : {#value %unshift, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%aiolambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (negOne = prim("-", 0, 1))

  label ret:
  if (len === 0) {
    break ret negOne
  } else { undefined };

  let (n = if (args["1"] === undefined) { 0 } else { %ToInteger(args["1"]) })
  if (prim(">=", n, len)) {
    break ret negOne
  } else { undefined };

  rec (loop = func(k) {
    if (prim("<", k, len)) {
      let (kStr = %ToString(k))
      if (prim("hasProperty", O, kStr)) {
        let (elementK = O[kStr])
        if (args["0"] === elementK) {
          break ret k
        } else { undefined };
        loop(prim("+", k, 1))
      } else { 
        loop(prim("+", k, 1))
      }
    } else { undefined }
  })
  let (start = if (prim(">=", n, 0)) { n } else {
    %max(prim("-", len, prim("abs", n)), 0)
  })
  loop(start);
  break ret negOne
}

let [%arrayIndexOf] = {[#code : %aiolambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%arrayIndexOf,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "indexOf",
  {[] "value" : {#value %arrayIndexOf, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%aliolambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenValue = O["length"])
  let (len = %ToUint32(lenValue))
  let (negOne = prim("-", 0, 1))

  label ret:
  if (len === 0) {
    break ret negOne
  } else { undefined };

  let (n = if (args["1"] === undefined) { prim("-", len, 1) } 
    else { %ToInteger(args["1"]) })
  rec (loop = func(k) {
    if (prim(">=", k, 0)) {
      let (kstr = %ToString(k))
      if (prim("hasProperty", O, kstr)) {
        if (O[kstr] === args["0"]) {
          break ret k
        } else { loop(prim("-", k, 1)) }
      } else { loop(prim("-", k, 1)) } 
    } else { undefined }
  })

  let (start = if (prim(">=", n, 0)) { %min(n, prim("-", len, 1)) }
    else { prim("-", len, prim("abs", n)) })
  loop(start);
  break ret negOne
}

let [%arrayLastIndexOf] = {[#code : %aliolambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%arrayLastIndexOf,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "lastIndexOf",
  {[] "value" : {#value %arrayLastIndexOf, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%foreachlambda] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (callbackfn = args["0"])
  
  label ret:

  if (prim("typeof", callbackfn) !== "function") {
    throw {[#proto : %TypeErrorProto,]}
  } else { undefined };

  let (T = args["1"])
  rec (loop = func(k) {
    if (prim("<", k, len)) {
      let (Pk = %ToString(k))
      if (prim("hasProperty", O, Pk)) {
        let (kValue = O[Pk])
        let (argslist = 
          {[] "0" : {#value kValue, #writable true},
              "1" : {#value k, #writable true},
              "2" : {#value O, #writable true}})
        callbackfn(T, argslist);
        loop(prim("+", k, 1))
      } else {
        loop(prim("+", k, 1))
      }
    } else { undefined }
  })
  loop(0);
  undefined
}

let [%foreach] = {[#code : %foreachlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%foreach,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "forEach",
  {[] "value" : {#value %foreach, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%slicelambda] = func(this, args) {
  let (O = %ToObject(this))
  let (A = {[#proto : %ArrayProto, #class : "Array",]})
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (relativeStart = %ToInteger(args["0"]))

  let (initk = if (prim("<", relativeStart, 0)) {
    let (added = prim("+", len, relativeStart))
    if (prim(">", added, 0)) { added } else { 0 }
    } else {
      if (prim("<", relativeStart, len)) { relativeStart } else { len }
    })

  let (relativeEnd = if (args["1"] === undefined) { len } 
    else { %ToInteger(args["1"]) })

  let (final = if (prim("<", relativeEnd, 0)) {
    let (added = prim("+", len, relativeEnd))
    if (prim(">", added, 0)) { added } else { 0 }
  } else {
    if (prim("<", relativeEnd, len)) { relativeEnd } else { len }
  })

  rec (loop = func(n, k, finalLen) {
    label ret:
    if (prim(">=", k, final)) {
      break ret finalLen
    } else { null };

    let (Pk = %ToString(k))
    let (kPresent = prim("hasProperty", O, Pk))
    if (kPresent) {
      let (kValue = O[Pk])
      %defineOwnProperty(A,
        %ToString(n),
        {[] "value" : {#value kValue, #writable true},
            "writable" : {#value true, #writable true},
            "configurable" : {#value true, #writable true},
            "enumerable" : {#value true, #writable true}});
      break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
    } else {
      break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
    }
  })

  A["length" = loop(0, initk, 0)];
  A
}

let [%slice] = {[#code : %slicelambda, #proto : %FunctionProto,]}

{ %defineOwnProperty(%slice,
    "length",
    {[] "value" : {#value 2, #writable true},
        "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
    "slice",
    {[] "value" : {#value %slice, #writable true},
        "configurable" : {#value true, #writable true}}) }

let [%numToStringAbstract] = func(n, r) {
  rec (nts = func(n, r) {
    label ret:
    if (n !== n) {
      break ret "NaN"
    } else { null };

    if (n === 0) {
      break ret "0"
    } else { null };

    if (prim("<", n, 0)) {
      let (negOne = prim("-", 0, 1))
      let (newN = prim("*", n, negOne))
      break ret prim("string+", "-", nts(newN, r))
    } else { null };

    if (n === +inf) {
      break ret "Infinity"
    } else { null };

    if (r === 10) {
      break ret prim("prim->str", n)
    } else { null };
    break ret prim("base", n, r)
  })
  nts(n, r)
}

let [%numberToStringlambda] = func(this, args) {
  let (notNumProto = this !== %NumberProto)
  if (notNumProto && prim("get-proto", this) !== %NumberProto) {
    throw {[#proto : %TypeErrorProto,]}
  } else { 
    let (rint = if (args["0"] === undefined) { 10 } else { %ToInteger(args["0"]) })
    if (rint === 10) {
      %numToStringAbstract(prim("get-primval", this), 10)
    } else {
      if (prim("!", prim("typeof", rint) === "number")) {
        throw "RangeError"
      } else {
        if (prim("<", rint, 2) || prim(">", rint, 36)) {
          throw "RangeError"
        } else {
          %numToStringAbstract(prim("get-primval", this), rint)
        }
      }
    }
  }
}

let [%numberToString] = 
  { [#code : %numberToStringlambda,] 
    "length" : {#value 0, #writable false} }

{%defineOwnProperty(%NumberProto,
  "toString",
  {[] "value" : {#value %numberToString, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }
//{%NumberProto["toString" = %numberToString]}

let [%StringIndexOflambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (searchStr = %ToString(args["0"]))
  let (pos = %ToInteger(args["1"]))
  let (len = prim("strlen", S))
  let (start = %min(%max(pos, 0), len))
  let (searchLen = prim("strlen", searchStr))

  let (check_k = func(k) {
    rec (check_j = func(j) {
      if (j === searchLen) { true } else {
        if (prim("char-at", S, prim("+", k, j)) !== prim("char-at", searchStr, j)) {
          false
        } else { check_j(prim("+", j, 1)) }
      }
    })
    if (prim("!", prim("<=", prim("+", k, searchLen), len))) { false } else {
      if (prim("!", check_j(0))) { false } else { true }
    }
  })
  rec (find_k = func(curr) {
    if (prim(">", prim("+", curr, searchLen), len)) { prim("-", 0, 1) } else {
      if (check_k(curr)) { curr } else {
        find_k(prim("+", curr, 1))
      }
    }
  })

  find_k(start)
}

let [%StringIndexOf] = { [#code : %StringIndexOflambda, #proto : %FunctionProto,]}

{ %StringIndexOf["length" = 1];
  %StringIndexOf["length"<#enumerable> = false];
  %StringIndexOf["length"<#configurable> = false];
  %StringIndexOf["length"<#writable> = false];
  %StringProto["indexOf" = %StringIndexOf]}

let [%sliolambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (searchStr = %ToString(args["0"]))
  let (numPos = %ToNumber(args["1"]))
  let (pos = 
    if (numPos !== numPos) { 
      +inf
    } else { %ToInteger(numPos) })
  let (len = prim("strlen", S))
  let (start = %min(%max(pos, 0), len))
  let (searchLen = prim("strlen", searchStr))

  let (check_k = func(k) {
    rec (check_j = func(j) {
      if (j === searchLen) { true } else {
        if (prim("char-at", S, prim("+", k, j)) !== prim("char-at", searchStr, j)) {
          false
        } else { check_j(prim("+", j, 1)) }
      }
    })
    if (prim("!", prim("<=", prim("+", k, searchLen), len))) { false } else {
      if (prim("!", check_j(0))) { false } else { true }
    }
  })
  rec (find_k = func(curr) {
    if (prim("<", curr, 0)) { prim("-", 0, 1) } else {
      if (check_k(curr)) { curr } else {
        find_k(prim("-", curr, 1))
      }
    }
  })

  find_k(start)
}

let [%StringLastIndexOf] = {[#code : %sliolambda, #proto : %FunctionProto,]}

{ %StringLastIndexOf["length" = 1];
  %StringLastIndexOf["length"<#enumerable> = false];
  %StringLastIndexOf["length"<#configurable> = false];
  %StringLastIndexOf["length"<#writable> = false];
  %StringProto["lastIndexOf" = %StringLastIndexOf]}

let [%localeCompareLambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (That = %ToString(args["0"]))
  prim("locale-compare", S, That)
}

let [%localeCompare] = {[#code : %localeCompareLambda, #proto : %FunctionProto,]}

{ %localeCompare["length" = 1];
  %localeCompare["length"<#enumerable> = false];
  %localeCompare["length"<#configurable> = false];
  %localeCompare["length"<#writable> = false];
  %StringProto["localeCompare" = %localeCompare]}

let [%stringSliceLambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  let (len = prim("strlen", S))
  let (intStart = %ToInteger(args["0"]))
  let (end = args["1"])
  let (intEnd = if (end === undefined) { len } else { %ToInteger(end) })
  let (from = if (prim("<", intStart, 0)) { 
    %max(prim("+", len, intStart), 0) } else { %min(intStart, len) })
  let (to = if (prim("<", intEnd, 0)) { 
    %max(prim("+", len, intEnd), 0) } else { %min(intEnd, len) })
  let (span = %max(prim("-", to, from), 0))
  rec (build = func(i, result) {
    if (prim("<", i, span)) {
      let (next = prim("string+", result, prim("char-at", S, prim("+", from, i))))
      build(prim("+", i, 1), next)
    } else { result }
  })
  build(0, "")
}

let [%stringSlice] = {[#code : %stringSliceLambda, #proto : %FunctionProto,]}

{ %stringSlice["length" = 2];
  %stringSlice["length"<#enumerable> = false];
  %stringSlice["length"<#configurable> = false];
  %stringSlice["length"<#writable> = false];
  %StringProto["slice" = %stringSlice]}

let [%tlclambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  prim("to-lower", S)
}

let [%toLowerCase] = {[#code : %tlclambda, #proto : %FunctionProto,]}

{%StringProto["toLowerCase" = %toLowerCase]}

let [%tuclambda] = func(this, args) {
  %CheckObjectCoercible(this);
  let (S = %ToString(this))
  prim("to-upper", S)
}

let [%toUpperCase] = {[#code : %tuclambda, #proto : %FunctionProto,]}

{%StringProto["toUpperCase" = %toUpperCase]}

// Turkish language support NYI
{%StringProto["toLocaleLowerCase" = %toLowerCase];
 %StringProto["toLocaleUpperCase" = %toUpperCase]}

let [%MakeDate] = func(day, time) { 0 } // TODO: implement

let [%MakeDay] = func(yr, mt, dt) { 0 } // TODO: implement

let [%MakeTime] = func(h, min, s, milli) { 0 } // TODO: implement

let [%UTC] = func(v) { 0 } // TODO: implement

let [%getYearlambda] = func(this, args) { 78 } // TODO: implement

let [%getYear] = { [#code : %getYearlambda,] }

let [%getMonthlambda] = func(this, args) { 3 } // TODO: implement

let [%getMonth] = { [#code: %getMonthlambda,] }

let [%DateProto] = { 
  [#proto : %ObjectProto,]
  "getYear" : {#value %getYear, #writable false},
  "getMonth": {#value %getMonth, #writable false},
}

let [%DateConstructor] = func(this, args) {
  let (calledAsFunction = this === %global)
  let (nargs = args["length"])
  if (nargs === "0") {
    let (v = %getCurrentUTC())
    { [#proto : %DateProto, #class : "Date", #extensible : true, #value : v,] }
  } else {
    if (nargs === "1") {
      let (v = %ToPrimitive(args["0"]))
      let (V =
        if (prim("typeof", v) === "string") { %parse(v) } else { %ToNumber(v) })
      let (clipped = %TimeClip(V))
      { [#proto : %DateProto, #class : "Date", #extensible : true, #value : clipped,] }
    } else {
      let (y = %ToNumber(args["0"]))
      let (m = %ToNumber(args["1"]))
      let (dt = if (args["2"] === undefined) { 1 } else { %ToNumber(args["2"]) })
      let (h = if (args["3"] === undefined) { 0 } else { %ToNumber(args["3"]) })
      let (min = if (args["4"] === undefined) { 0 } else { %ToNumber(args["4"]) })
      let (s = if (args["5"] === undefined) { 0 } else { %ToNumber(args["5"]) })
      let (milli = if (args["6"] === undefined) { 0 } else { %ToNumber(args["6"]) })
      let (yr = 
        let (tiy = %ToInteger(y))
        let (rangecond1 = prim("<", 0, tiy) || 0 === tiy)
        let (rangecond2 = prim("<", tiy, 99) || tiy === 99)
        if (y !== y && rangecond1 && rangecond2) {
          prim("+", 1900, tiy) } else { y })
      let (finalDate = %MakeDate(%MakeDay(yr, m, dt), %MakeTime(h, min, s, milli)))
      let (primval = %UTC(%TimeClip(finalDate)))
      { [#proto : %DateProto, #class : "Date", #extensible : true, #value : primval,] }
    }
  }
}

let [%DateGlobalFuncObj] = { [#code : %DateConstructor, #proto : %FunctionProto,]
                             "prototype" : {#value %DateProto, #writable true} }

let [%testlambda] = func(this, args) {
  prim("print", "test")
}

let [%test] = { [#code : %testlambda,] }

let [%RegexpProto] = { []
  "test" : {#value %test, #writable false} }


let [%parseIntlambda] = func(n) {
  undefined
}

let [%parseInt] = { [#code : %parseIntlambda,] }

let [%explambda] = func() {
  undefined
}

let [%exp] = { [#code : %explambda,] }

let [%Math] = { []
  "LN2" : {#value 0.6931471805599453, #writable false},
  "PI" : {#value 3.141592653589793, #writable false},
  "exp" : {#value %exp, #writable false} }

let [%minMaxLambda] = func(this, args, op, init) {
  let (end = args["length"])

  label ret:
  if (end === 0) {
    break ret init
  } else { null };

  rec (loop = func(best, i) {
    if (prim("<", i, end)) {
      let (curr = %ToNumber(args[prim("prim->str", i)]))
      if (curr !== curr) {
        break ret NaN
      } else { null };

      loop(op(best, curr), prim("+", i, 1))
    } else { best }
  })
  break ret loop(init, 0)
}

let [%mathMinLambda] = func(this, args) {
  %minMaxLambda(this, args, %min, +inf)
}

let [%mathMin] = {[#code : %mathMinLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%mathMin,
  "length",
  {[] "value" : {#value 2, #writable true},
      "configurable" : {#value false, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%Math,
  "min",
  {[] "value" : {#value %mathMin, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathMaxLambda] = func(this, args) {
  %minMaxLambda(this, args, %max, -inf)  
}

let [%mathMax] = {[#code : %mathMaxLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%mathMax,
  "length",
  {[] "value" : {#value 2, #writable true},
      "configurable" : {#value false, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%Math,
  "max",
  {[] "value" : {#value %mathMax, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathAbsLambda] = func(this, args) {
  let (n = %ToNumber(args["0"]))
  label ret:
  if (n !== n) { break ret n } else { null };
  if (n === -inf) { break ret +inf} else { null };
  break ret prim("abs", n)
}

let [%mathAbs] = {[#code : %mathAbsLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "abs",
  {[] "value" : {#value %mathAbs, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathLogLambda] = func(this, args) {
  let (n = %ToNumber(args["0"]))
  label ret:
  if (n !== n) { break ret n } else { null };
  if (prim("<", n, 0)) { break ret NaN } else { null };
  if (n === 0) { break ret -inf } else { null };
  if (n === 1) { break ret 0 } else { null };
  if (n === +inf) { break ret n } else { null };
  break ret prim("log", n)
}

let [%mathLog] = {[#code : %mathLogLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "log",
  {[] "value" : {#value %mathLog, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathCeilLambda] = func(this, args) {
  let (x = %ToNumber(args["0"]))
  label ret:
  if (x !== x || x === 0 || x === -inf || x === +inf) {
    break ret x
  } else { null };
  break ret prim("ceil", x)
}

let [%mathCeil] = {[#code : %mathCeilLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "ceil",
  {[] "value" : {#value %mathCeil, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%mathFloorLambda] = func(this, args) {
  let (x = %ToNumber(args["0"]))
  label ret:
  if (x !== x || x === 0 || x === -inf || x === +inf) {
    break ret x
  } else { null };
  break ret prim("floor", x)
}
  
let [%mathFloor] = {[#code : %mathFloorLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
  "floor",
  {[] "value" : {#value %mathFloor, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%PrimAdd] = func(l, r) {
    let (l = %ToPrimitive(l))
    let (r = %ToPrimitive(r))
  if (prim("stx=", prim("typeof", l), "string")) {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else if (prim("stx=", prim("typeof", r), "string")) {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else {
    let (lnum = prim("prim->num", l))
    let (rnum = prim("prim->num", r))
    prim("+", lnum, rnum)
  }
}

let [%mathPowLambda] = func(this, args) {
    let (x = %ToNumber(args["0"]))
    let (y = %ToNumber(args["1"]))

    label ret:
    if (y !== y) {
        break ret NaN
    } else { null };

    if (y === 0) {
        break ret 1
    } else { null };

    if (x !== x && y !== 0) {
        break ret NaN
    } else { null };

    let (absX = prim("abs", x))
    if (prim(">", absX, 1) && y === +inf) {
        break ret +inf
    } else { null };

    if (prim(">", absX, 1) && y === -inf) {
        break ret 0
    } else { null };

    if (absX === 1 && ((y === +inf) || (y === -inf))) {
        break ret NaN
    } else { null };

    if (prim("<", absX, 1) && y === +inf) {
        break ret 0
    } else { null };

    if (prim("<", absX, 1) && y === -inf) {
        break ret +inf
    } else { null };

    if (x === +inf && prim(">", y, 0)) {
        break ret +inf
    } else { null };

    if (x === +inf && prim("<", y, 0)) {
        break ret 0
    } else { null };

    let (isOdd = func(n) {
        let (divided = prim("/", n, 2))
        (prim("floor", n) === n) && (prim("floor", divided) !== divided)
    })
    if (x === -inf && prim(">", y, 0)) {
        break ret if (isOdd(y)) { -inf } else { +inf }
    } else { null };

    if (x === -inf && prim("<", y, 0)) {
        break ret 0
    } else { null };

    if (x === 0 && prim(">", y, 0)) {
        break ret 0
    } else { null };

    if (x === 0 && prim("<", y, 0)) {
        break ret +inf
    } else { null };

    // If x is -0 and y<0 and y is an odd integer, the result is -inf
    // If x is -0 and y<0 and y is not an odd integer, the result +inf
    let (oddY = isOdd(y))
    if (x === 0 && prim("<", y, 0) && oddY) {
        break ret -inf
    } else { null };
    if (x === 0 && prim("<", y, 0)) {
        break ret +inf
    } else { null };

    let (isFinite = func(n) {
        n !== +inf && n !== -inf
    })
    let (finiteX = isFinite(x))
    let (finiteY = isFinite(y))
    if (prim("<", x, 0) && finiteX && finiteY && prim("floor", y) !== y) {
        break ret NaN
    } else { null };

    break ret prim("pow", x, y)
}

let [%mathPow] = {[#code : %mathPowLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%Math,
    "pow",
    {[] "value" : {#value %mathPow, #writable true},
        "configurable" : {#value true, #writable true}}) }

let [%valueOfLambda] = func(this, args, proto, typestr) {
  let (hasWrongProto = prim("get-proto", this) !== proto)
  let (hasWrongTypeof = typeof(this) !== typestr)
  let (isntProto = this !== proto)
  if (hasWrongProto && hasWrongTypeof && isntProto) {
    throw {[#proto : %TypeErrorProto,]}
  } else {
    if (hasWrongTypeof) { prim("get-primval", this) } else { this }
  }
}

let [%stringValueOf] = 
  {[#code : func(this, args) { 
      %valueOfLambda(this, args, %StringProto, "string") 
    },
    #proto : %FunctionProto,]}

{%defineOwnProperty(%StringProto,
  "valueOf",
  {[] "value" : {#value %stringValueOf, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%numValueOf] = 
  {[#code : func(this, args) { 
      %valueOfLambda(this, args, %NumberProto, "number") 
    },
    #proto : %FunctionProto,]}

{%defineOwnProperty(%NumberProto,
  "valueOf",
  {[] "value" : {#value %numValueOf, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%booleanValueOf] = 
 {[#code : func(this, args) { 
    %valueOfLambda(this, args, %BooleanProto, "boolean")
  },
  #proto : %FunctionProto,]}

{%defineOwnProperty(%BooleanProto,
  "valueOf",
  {[] "value" : {#value %booleanValueOf, #writable true},
      "writable" : {#value true, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [%PrimSub] = func(l, r) {
    let (l = %ToPrimitiveHint(l, "number"))
    let (r = %ToPrimitiveHint(r, "number"))
    prim("-", l, r)
}

let [%PrimMultOp] = func(l, r, op) {
  let (lValue = 
    if (prim("typeof", l) === "object") {
      prim("get-primval", l)
    } else { l })
  let (rValue = 
    if (prim("typeof", l) === "object") {
      prim("get-primval", r)
    } else { r })
  let (lNum = %ToNumber(lValue))
  let (rNum = %ToNumber(rValue))
  op(lNum, rNum)
}

// Used internally
let [%mkArgsObj] = func(args) {
  let (keys = prim("own-property-names", args))
  let (errorer = {[#code: func(this, args) {
    %ThrowTypeError(null, null)
  },]})
  let (argsObj = {[#proto: %ObjectProto,
                   #class: "Arguments",
                   #extensible: true,]
                   "callee" : {#getter errorer, #setter errorer},
                   "caller" : {#getter errorer, #setter errorer}})
  rec (loop = func(iter) {
    let (strx = %ToString(iter))
    if (prim("hasOwnProperty", keys, strx)) {
      %defineOwnProperty(argsObj, strx, {
        []
        "value" : {#value args[strx], #writable false},
        "writable" : {#value true, #writable false},
        "configurable": {#value false, #writable false},
        "enumerable": {#value true, #writable false}
      });
      loop(prim("+", iter, 1))
    }
    else {
      %defineOwnProperty(argsObj, "length", {
        []
        "value" : {#value iter, #writable false},
        "writable" : {#value false, #writable false},
        "configurable": {#value false, #writable false},
        "enumerable": {#value false, #writable false}
      })
    }
  })
  loop(0);
  argsObj
}

let [%ArrayLengthChange] = func(arr, newlen) {
  let (oldlen = %ToUint32(arr["length"]))
  rec (fix = func(i) {
    if (prim("<", i, oldlen)) {
      arr[delete prim("prim->str", i)];
      fix(prim("+", i, 1))
    }
  })
  fix(newlen)
}

// 15.4: A property name P (in the form of a String value) is an array index if and
// only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal to
// 2^32−1
let [%set-property] = func(obj, fld, val) {
  let (obj = %ToObject(obj))
  let (fld = %ToString(fld))
  let (isArrayIndex = func() {
    let (uint = %ToUint32(fld))
      if (%ToString(uint) === fld) {
        uint !== 4294967295.0
      }
      else {
        false
      }
  })
  let (setArrayField = func() {
    let (lenCheck = func() {
      if (fld === "length") {
        let (newLen = %ToUint32(val))
        let (toCompare = %ToNumber(val))
        if (newLen !== toCompare) {
          throw {[#proto : %RangeErrorProto,]}
        } else {
          if (prim("<", newLen, obj["length"])) {
            %ArrayLengthChange(obj, newLen)
          } else { undefined }
        }
      } else { undefined }
    })
    lenCheck();

    obj[fld = if (fld === "length") { %ToUint32(val) } else { val }];

    if (isArrayIndex()) {
      let (uint = %ToUint32(fld))
      let (len = obj["length"])
      if (prim("<", len, prim("+", uint, 1))) {
        obj["length" = prim("+", uint, 1)]
      } else { undefined }
    }
    else { undefined }
  })
  if (prim("get-class", obj) === "Array") {
    setArrayField()
  }
  else {
    obj[fld = val]
  }
}

// 11.4.6
let [%UnaryPlus] = func(expr) {
  let (val = if (prim("typeof", expr) === "object") {
    prim("get-primval", expr) } else { expr })
  %ToNumber(val)
}

// 11.4.7
let [%UnaryNeg] = func(expr) {
  let (oldValue = %ToNumber(expr))
  if (oldValue !== oldValue) {
    // NaN
    oldValue
  } else {
    let (negOne = prim("-", 0, 1))
    prim("*", oldValue, negOne)
  }
}

{
  %global["print" = %print];
  %global["Array" = %ArrayGlobalFuncObj];
  %global["String" = %StringGlobalFuncObj];
  %global["Object" = %ObjectGlobalFuncObj];
  %global["Number" = %NumberGlobalFuncObj];
  %global["Boolean" = %BooleanGlobalFuncObj];
  %global["Date" = %DateGlobalFuncObj];
  %global["Function" = %FunctionGlobalFuncObj];
  %global["isNaN" = %isNaN];
  %global["Math" = %Math];
  %global["parseInt" = %parseInt];
  %global["TypeError" = %TypeErrorGlobalFuncObj];
  %global["RangeError" = %RangeErrorGlobalFuncObj];

  %ObjectProto["propertyIsEnumerable" = %propertyIsEnumerable];
  %ObjectProto["propertyIsEnumerable"<#enumerable> = false];

  %ObjectProto["defineProperty" = %defineProperty];
  %ObjectProto["defineProperty"<#enumerable> = false]
}

let [%context] = %global

let [%evallambda] = func(this, args) {
    @eval(args["0"])
}

let [%eval] = { [#code : %evallambda,] }

{%global["eval" = %eval];
 %global["eval"<#enumerable> = false]}

{%global["NaN" = NaN];
 %global["NaN"<#enumerable> = false];
 %global["NaN"<#configurable> = false];
 %global["NaN"<#writable> = false]}

{%global["Infinity" = +inf];
 %global["Infinity"<#enumerable> = false];
 %global["Infinity"<#configurable> = false];
 %global["Infinity"<#writable> = false]}

let [%isFiniteLambda] = func(this, args) {
  let (n = %ToNumber(args["0"]))
  prim("!", (n !== n || n === +inf || n === -inf))
}

let [%isFinite] = {[#code : %isFiniteLambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%global,
  "isFinite",
  {[] "value" : {#value %isFinite, #writable true},
      "enumerable" : {#value false, #writable true},
      "configurable" : {#value true, #writable true},
      "writable" : {#value true, #writable true}}) }

let [%this] = %global
