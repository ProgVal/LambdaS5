let [[%ToString]] = func (s) {
    if(prim("primitive?", s)) {
        prim("prim->str", s)
    }
    else {
        "non-primitive"
    }
}

let [[%print]] = func(o, s) {
    prim("print", %ToString(s["0"]))
}

let [[%push]] = func(this, args) {
  this[ prim("prim->str", this["length"]) = args["0"] ];
  this[ "length" = prim("+", this["length"], 1) ]
}

let [[%toString]] = func(this, args) {
    undefined
}

let [[%sort]] = func(this, args) {
    undefined
}

let [[%join]] = func(this, args) {
    let (list = this)
    let (separator = 
      if (prim("hasOwnProperty", args, prim("prim->str", 0))) {
        args[prim("prim->str", 0)]
      } else {
        ","
      })
    rec (inner_join = func(n, result) {
      if (prim("abs=", n, 0)) {
        prim("string+", %ToString(list[prim("prim->str", n)]), result) 
      } else {
        let (element = %ToString(list[prim("prim->str", n)]))
        let (next = 
        prim("string+", separator, prim("string+", element, result)))
        inner_join(prim("-", n, 1), next)
      }
    })
    let (start = prim("-", prim("prim->num", this["length"]), 1))
    inner_join(start, "")
}

let [[%eval]] = func(this, args) {
  prim("print", "eval")
}

let [[%isNaN]] = func(this, args) {
    undefined
}

let [[%replace]] = func(this, args) {
    undefined
}

let [[%hasOwnProperty]] = func(this, args) {
  prim("print", "hasOwnProperty")
}

let [[%getOwnPropertyDescriptor]] = func(this, args) {
  prim("print", "getOwnPropertyDescriptor")
}

let [[%len]] = func(list) {
    rec (inner_len = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                prim("+", 1, inner_len(prim("+", 1, iter)))
            }
            else { iter }
        })
    inner_len(0)
}

let [[%slice]] = func(list, min, max) {
    let (retObj = {[#extensible: true,]})
    rec (inner_slice = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                retObj[prim("prim->str", iter) = list[prim("prim->str", iter)] ];
                if(prim(">", iter, max)) { undefined }
                else { inner_slice(prim("+", iter, 1)) }
            }
            else { undefined }
        })
    inner_slice(min);
    retObj
}

let [[%call]] = func(this, args) {
    this(args["0"], %slice(args, 1, %len(args)))
}

let [[%test]] = func(this, args) {
  prim("print", "test")
}

let [[%ObjectProto]] = { [] 
  "toString" : {#value %toString, #writable false},
  "hasOwnProperty" : {#value %hasOwnProperty, #writable false},
  "getOwnPropertyDescriptor" : {#value %getOwnPropertyDescriptor, #writable false} }

let [[%FunctionProto]] = { []
  "toString" : {#value %toString, #writable false},
  "call" : {#value %call, #writable false} }

let [[%ArrayProto]] = { [] 
  "toString" : {#value %toString, #writable false},
  "push" : {#value %push, #writable false}, 
  "sort" : {#value %sort, #writable false},
  "join" : {#value %join, #writable false} }

let [[%StringProto]] = { [] 
  "toString" : {#value %toString, #writable false},
  "replace" : {#value %replace, #writable false} }

let [[%RegexpProto]] = { []
  "test" : {#value %test, #writable false} }

let [[%global]] = { [] 
  "eval" : {#value %eval, #writable false}, 
  "print" : {#value %print, #writable false}, 
  "Array" : {#value %ArrayProto, #writable false},
  "String" : {#value %StringProto, #writable false},
  "Object" : {#value %ObjectProto, #writable false},
  "Function" : {#value %FunctionProto, #writable false} }

let [[%ToBoolean]] = func(x) {
  if (prim("stx=", prim("typeof", x), "Object")) {
    true
  } else {
    prim("prim->bool", x)
  }
}

let [[%PrimAdd]] = func(l, r) {
  if (prim("stx=", prim("typeof", l), "string")) {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else if (prim("stx=", prim("typeof", r), "string")) {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else {
    prim("print", prim("typeof", l));
    let (lnum = prim("prim->num", l))
    let (rnum = prim("prim->num", r))
    prim("+", lnum, rnum)
  }
}

let [[%context]] = %global
