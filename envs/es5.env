let [[%global]] = { [] }

let [[%Object]] = {[]}

let [[%neginf]] = 0

let [[%getOwnPropertyDescriptorlambda]] = func(this, args) {
  prim("print", "getOwnPropertyDescriptor")
}

let [[%getOwnPropertyDescriptor]] = { [#code : %getOwnPropertyDescriptorlambda,] }


let [[%ObjectProto]] = { [] 
  "getOwnPropertyDescriptor" : {#value %getOwnPropertyDescriptor, #writable false},
 }

let [[%primValueOflambda]] = func(this, args) {
  prim("get-primval", this) 
}

let [[%booleanValueOf]] = { [#code : %primValueOflambda,] }

let [[%booleanToStringlambda]] = func(this, args) {
  let (t = prim("typeof", this))
  let (b = if (t === "boolean") { this } else {
    if (t === "object") {
      if (prim("get-class", this) === "Boolean") {
        prim("get-primval", this)
      } else { throw "TypeError" }
    } else { throw "TypeError" }
  })
  if (b) { "true" } else { "false" }
}

let [[%booleanToString]] = 
  { [#code : %booleanToStringlambda,] 
    "length" : {#value 0, #writable false} }

let [[%BooleanProto]] = { [#proto : %ObjectProto,]
  "toString" : {#value %booleanToString, #writable false}, 
  "valueOf" : {#value %booleanValueOf, #writable false},
}


let [[%BooleanConstructor]] = func(this, args) {
  let (pb = prim("prim->bool", args["0"]))
  { [#value : pb, #proto : %BooleanProto, #class : "Boolean",] }
}

let [[%BooleanGlobalFuncObj]] = { [#code : %BooleanConstructor, #proto : %BooleanProto,] }

{%BooleanProto["constructor" = %BooleanGlobalFuncObj];
 %BooleanGlobalFuncObj["prototype" = %BooleanProto]}

let [[%numberValueOf]] = { [#code : %primValueOflambda,] }


let [[%NumberProto]] = { [#proto : %ObjectProto,]
  "NEGATIVE_INFINITY" : {#value %neginf, #writable false},
  "MAX_VALUE" : {#value 1.79769313486231571e+308, #writable false},
  "MIN_VALUE" : {#value 2.22507385850720138e-308, #writable false},
  "toString" : {#value null, #writable true},
  "valueOf" : {#value %numberValueOf, #writable false},
}


let [[%ToBoolean]] = func(x) {
  prim("prim->bool", x)
//  if (prim("stx=", prim("typeof", x), "Object")) {
//    true
//  } else {
//    prim("prim->bool", x)
//  }
}

let [[%instanceof]] = func(o1, o2) {
    if(typeof o1 !== "object") {
        false
    }
    else {
      let (o2prototype = o2["prototype"])
      let (o1proto = prim("get-proto", o1))
      rec (instanceof = func(currproto) {
        if(currproto === null) {
           false
        }
        else {
          if(currproto === o1proto) {
            true
          }
          else {
            instanceof(prim("get-proto", currproto))
          }
        }
      })
      instanceof(o2prototype)
    }
}


let [[%replacelambda]] = func(this, args) {
    undefined
}

let [[%replace]] = { [#code : %replacelambda,] }

let [[%stringToStringlambda]] = func(this, args) {
  prim("get-primval", this)
}

let [[%stringToString]] = 
  { [#code : %stringToStringlambda,] 
    "length" : {#value 0, #writable false} }

let [[%stringValueOf]] = { [#code : %primValueOflambda,] }

let [[%StringProto]] = { [] 
  "toString" : {#value %stringToString, #writable false},
  "replace" : {#value %replace, #writable false},
  "valueOf" : {#value %stringValueOf, #writable false} }

let [[%ToObject]] = func (o) {
    label ret : 
    let (t = prim("surface-typeof", o))
    if (t === "object" || t === "function") {
       break ret o
    }
    else { null };
    if (t === "string") {
       break ret
       {[#class: "String", 
         #extensible: true,
         #proto: %StringProto,
         #value: o,]}
    }
    else { null };
    if (t === "number") {
       break ret
       {[#class: "Number",
         #extensible: true,
         #proto: %NumberProto,
         #value: o,]}
    }
    else { null };
    if (t === "boolean") {
       break ret
       {[#class: "Boolean",
         #extensible: true,
         #proto: %BooleanProto,
         #value: o,]}
    }
    else { null };  
    if (t === "function") {
      break ret
      {[#class: "Function",
        #extensible: true,
        #proto: %BooleanProto,
        #value: o,]}
    }
    else { null };
    throw t
}

let [[%TETSlambda]] = func(this, args) {
  "TypeError"
}

let [[%TEToString]] = 
  { [#code : %TETSlambda,] 
    "length" : {#value 0, #writable false} }

let [[%TypeErrorProto]] = { [#proto : %ObjectProto,] 
  "toString" : {#value %TEToString, #writable false} }

let [[%TypeErrorConstructor]] = func(this, args) {
  { [#proto : %TypeErrorProto,] }
}

let [[%TypeErrorGlobalFuncObj]] = 
  { [#code : %TypeErrorConstructor, #proto : %TypeErrorProto,] 
    "prototype" : {#value %TypeErrorProto, #writable false} }

{%TypeErrorProto["constructor" = %TypeErrorGlobalFuncObj]}

let [[%ThrowTypeError]] = {
    [ #code : func(this, args) {
        throw { [#proto : %TypeErrorProto,] }
      },]}

let [[%ToPrimitiveNum]] = func(obj) {
  let (check = func(o, str) {
    let (valueOf = o[str])
    if (prim("typeof", valueOf) === "function") {
        let (str = valueOf(o, {[]}))
        if (prim("primitive?", str)) {
            str
        } else { null }
    } else { null }
  })
  let (r1 = check(obj, "valueOf"))
  if (r1 !== null) { r1 } else {
    let (r2 = check(obj, "toString"))
    if (r2 !== null) { r2 } else {
      throw { [#proto : %TypeErrorProto,] }
    }
  }
}

let [[%ToPrimitiveStr]] = func(obj) {
    label ret :
    let (toString = obj["toString"])
    if (prim("typeof", toString) === "function") {
        let (str = toString(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    let (valueOf = obj["valueOf"])
    if (prim("typeof", valueOf) === "function") {
        let (str = valueOf(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    throw { [#proto : %TypeErrorProto,] }
}

let [[%ToPrimitiveHint]] = func(val, hint) {
    let (t = prim("typeof", val))
    if(t === "function" || t === "object") {
        if(hint === "string") {
            %ToPrimitiveStr(val)
        }
        else {
            %ToPrimitiveNum(val)
        }
    }
    else {
        val
    }
}

let [[%ToPrimitive]] = func(val) {
    // TODO exception for date objects
    %ToPrimitiveHint(val, "number")
}

let [[%ToString]] = func(val) {
    prim("prim->str", %ToPrimitiveHint(val, "string"))
}

let [[%StringConstructor]] = func(this, args) {
  let (ps = %ToString(args["0"]))
  { [#value : ps, #proto : %StringProto,] }
}

let [[%StringGlobalFuncObj]] = { [#code : %StringConstructor, #proto : %StringProto,] }

{%StringProto["constructor" = %StringGlobalFuncObj];
 %StringGlobalFuncObj["prototype" = %StringProto]}

let [[%ToNumber]] = func(val) {
    prim("prim->num", %ToPrimitiveHint(val, "number"))
}

let [[%NumberConstructor]] = func(this, args) {
  let (v = if (args["0"] === undefined) { 0 } else { %ToNumber(args["0"]) })
  { [#proto : %NumberProto, #class : "Number", #value : v,] }
}

let [[%NumberGlobalFuncObj]] = 
  { [#code : %NumberConstructor, #proto : %NumberProto,]
    "prototype" : {#value %NumberProto, #writable false} }

{%NumberProto["constructor" = %NumberGlobalFuncObj]}

let [[%isNaNlambda]] = func(this, args) {
    args["0"] !== args["0"]
}

// 11.9.3
let [[%EqEq]] = rec (eqeq = func(x1, x2) {
    label ret :
    let (t1 = prim("typeof", x1))
    let (t2 = prim("typeof", x2))
    if(t1 === t2) {
      if(t1 === "undefined") {
          break ret true
      }
      else {
          if(t1 === "null") {
              break ret true }
          else {
              if(t1 === "number") {
                  break ret (x1 === x2) }
              else {
                  if(t1 === "string") {
                      break ret (x1 === x2) }
                  else {
                      if(t1 === "object") {
                          break ret (x1 === x2) }
                      else {
                          throw "[env] Catastrophe---unknown type in ==" }
                  }}}}}
    else {

        if((x1 === undefined && x2 === null) ||
           (x1 === null && x2 === undefined)) {
            break ret true }
        else {
            if(t1 === "number" && t2 === "string") {
                break ret (x1 === prim("prim->num", x2)) }
            else {
                if(t1 === "string" && t2 === "number") {
                    break ret (prim("prim->num", x1) === x2) }
                else {
                    if(t1 === "boolean") {
                        break ret (eqeq(prim("prim->num", x1), x2)) }
                    else {
                        if (t2 === "boolean") {
                            break ret (eqeq(x1, prim("prim->num", x2))) }
                        else {
                            if((t1 === "string" || t1 === "number") &&
                               (t2 === "object")) {
                                break ret eqeq(x1, %ToPrimitive(x2)) }
                            else {
                                if((t2 === "string" || t2 === "number") &&
                                   (t1 === "object")) {
                                    break ret eqeq(%ToPrimitive(x1), x2) }
                                else {
                                    break ret false }
                            }}}}}}}}) eqeq
    

let [[%isNaN]] = { [#code : %isNaNlambda,] }

let [[%printlambda]] = func(o, s) {
    prim("print", %ToString(s["0"]))
}

let [[%print]] = { [#code : %printlambda,] }

let [[%len]] = func(list) {
    rec (inner_len = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                prim("+", 1, inner_len(prim("+", 1, iter)))
            }
            else { iter }
        })
    inner_len(0)
}

let [[%slice]] = func(list, min, max) {
    let (retObj = {[#extensible: true,]})
    rec (inner_slice = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                retObj[prim("prim->str", iter) = list[prim("prim->str", iter)] ];
                if(prim(">", iter, max)) { undefined }
                else { inner_slice(prim("+", iter, 1)) }
            }
            else { undefined }
        })
    inner_slice(min);
    retObj
}


let [[isDataField]] = func(obj, field) {
    ((obj[field<#value>] !== undefined) ||
     (obj[field<#writable>] !== undefined))
}

let [[isAccessorField]] = func(obj, field) {
    ((obj[field<#setter>] !== undefined) ||
     (obj[field<#getter>] !== undefined))
}

let [[isGenericField]] = func(obj, field) {
    (isDataField(obj, field) === false &&
     isAccessorField(obj, field) === false)
}

let [[isDataDescriptor]] = func(attr-obj) {
    (typeof (attr-obj["value"]) !== "undefined" ||
     typeof (attr-obj["writable"]) !== "undefined")
}

let [[isAccessorDescriptor]] = func(attr-obj) {
    (typeof (attr-obj["set"]) !== "undefined" ||
     typeof (attr-obj["get"]) !== "undefined")
}

let [[isGenericDescriptor]] = func(attr-obj) {
    (isAccessorDescriptor(attr-obj) === false &&
     isDataDescriptor(attr-obj) === false)
}

let [[copy-when-defined]] = func(obj1, obj2, s) {
    if(obj2[s] !== undefined) {
	obj1[s = obj2[s] ]
    }
    else { undefined }
}

let [[copy-data-desc]] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "writable");
    copy-when-defined(obj1, obj2, "value");
    obj1[delete "get"];
    obj1[delete "set"]

}

let [[copy-access-desc]] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "set");
    copy-when-defined(obj1, obj2, "get");
    obj1[delete "value"];
    obj1[delete "writable"]
}

/* 8.12.9 */
let [[%defineOwnProperty]] = func(obj, field, attr-obj) {
    let (t = typeof obj)
    if (t !== "object" && t !== "function") { throw "defineOwnProperty didn't get object" }
    //if (typeof obj !== "object") { throw "defineOwnProperty didn't get object" }
    else {
	let (fstr = %ToString(field))
	if (prim("hasOwnProperty", obj, fstr) === false) {
	    if (prim("is-extensible", obj)) {
		// Do this to open it up for the other properties (will set these last)
		obj[field<#configurable> = true];
		obj[field<#writable> = true];

		{if(isDataDescriptor(attr-obj)) {
		    obj[field<#value> = attr-obj["value"] ];
		    obj[field<#writable> = %ToBoolean(attr-obj["writable"]) ]
		}
		else if(isAccessorDescriptor(attr-obj)) {
		    obj[field<#getter> = attr-obj["get"] ];
		    obj[field<#setter> = attr-obj["set"] ]
		}
		 else { undefined }};

		obj[field<#enumerable> = %ToBoolean(attr-obj["enumerable"]) ];
		obj[field<#configurable> = %ToBoolean(attr-obj["configurable"]) ];
		true
	    }
	    else { throw type_error("(defineOwnProperty) Attempt to add a property to a non-extensible object.") }
	}
	else { /* it definitely has the property */
	    if (obj[field<#configurable>] === false) {
		if (attr-obj["configurable"] === true) {
		    throw type_error("escalating configurable from false to true")
		}
		else {
		    if(attr-obj["enumerable"] ===
		       (obj[field<#enumerable>] === false)) {
			throw type_error("(defineOwnPoperty) Can't change enumerable of a non-configurable property")
		    }
		}
	    };
	    
	    {if ((isDataDescriptor(current-prop)) !== (isDataDescriptor(attr-obj))) {
		if (obj[field<#configurable>] === false) {
		    throw type_error("(defineOwnProperty) Non-configurable property")
		}
		else {
		    if (isDataDescriptor(current)) {
			copy-data-desc(current-obj, attr-obj)
		    }
		    else {
			copy-access-desc(current-obj, attr-obj)
		    }
		}
	    }
	    else if ((isDataDescriptor(current-prop)) && 
		     (isDataDescriptor(attr-obj))) {
		if (current-prop["configurable"] === false) {
		    if (current-prop["writable"] === false) {
			if (attr-obj["writable"] === true) {
			    throw type_error("(defineOwnProperty) Cannot escalate writable from false to true.")
			}
			else {
			    if (attr-obj["value"] !== current-prop["value"]) {
				throw type_error("(defineOwnProperty) Cannot change a non-configurable value")
			    }
			    else { copy-data-desc(current-prop, attr-obj) }
			}
		    }
		    else { copy-data-desc(current-prop, attr-obj) }
		}
		else { copy-data-desc(current-prop, attr-obj) }
	    }
	    else {
		if (current-prop["configurable"] === false) {
		    if (current-prop["set"] !== attr-obj["set"] ||
			current-prop["get"] !== attr-obj["get"]) {
			throw type_error("(defineOwnProperty) Cannot change setter or getter of non-configurable property.")
		    }
		    else { copy-access-desc(current-prop, attr-obj) }
		}
		else { copy-access-desc(current-prop, attr-obj) }
	    }};

	    if(isDataDescriptor(current-prop)) {
		obj[field<#value> = current-prop["value"] ];
		obj[field<#writable> = current-prop["writable"] ]
	    }
	    else if(isAccessorDescriptor(current-prop)) {
		obj[field<#getter> = current-prop["get"] ];
		obj[field<#setter> = current-prop["set"] ]
	    }
	    else { undefined };
	    
	    obj[field<#enumerable> = current-prop["enumerable"] ];
	    obj[field<#configurable> = current-prop["configurable"] ];

	    true
	}
    }
}

let [[%definePropertylambda]] = func(this, args) {
    let (obj = args["0"])
    let (field = args["1"])
    let (propobj = args["2"])
    /* 8.10.5 checks */
    
    if ((typeof obj) !== "object") {
	throw type_error("defineProperty didn't get object")
    }
    else {
	let (attrobj = {[#extensible: true,]})
	let (enumerable = propobj["enumerable"])
	{if ((typeof enumerable) !== "undefined") {
	    attrobj["enumerable" = enumerable]
	}
	 else { attrobj }};

	let (configurable = propobj["configurable"])
	{if ((typeof configurable) !== "undefined") {
	    attrobj["configurable" = configurable]
	}
	 else { attrobj }};
	
	let (writable = propobj["writable"])
	{if ((typeof writable) !== "undefined") {
	    attrobj["writable" = writable]
	}
	 else { attrobj }};
	
	let (value = propobj["value"])
	{if ((typeof value) !== "undefined") {
	    attrobj["value" = value]
	}
	 else { attrobj }};
	
	let (get = propobj["get"])
	{if ((typeof get) !== "undefined" && 
	     (prim("surface-typeof", get) !== "function")) {
	    throw type_error("defineProperty given a non-function getter")
	}
	 else {
	     attrobj["get" = get]
	 }};
	
	let (set = propobj["set"])
	{if (typeof set !== "undefined" && 
	     (prim("surface-typeof", set) !== "function")) {
	    throw type_error("defineProperty given a non-function setter")
	}
	 else {
	     attrobj["set" = set]
	 }};

	// 8.10.5, step 9
	if ((isDataDescriptor(attrobj)) && 
            (isAccessorDescriptor(attrobj))) {
            throw "TypeError --- both accessor and data"
//	    throw type_error("The attributes given to defineProperty were inconsistent")
	}
	else {
	    %defineOwnProperty(obj, field, attrobj)
	}
    }	   
}

let [[%defineProperty]] = { [#code : %definePropertylambda,] }


 let [[%ObjectConstructor]] = func(this, args) {
  let (calledAsFunction = this === %global)
  let (hasArg = prim(">", args["length"], 0))
  let (notNull = prim("!", args["0"] === null))
  let (notUndefined = prim ("!", args["0"] === undefined))
  let (shouldReturnEarly =
    calledAsFunction && hasArg && notNull && notUndefined)
  let (defaultRtn = { [#proto : %ObjectProto,] })
  if (shouldReturnEarly) {
    %ToObject(args["0"])
  } else {
    if (hasArg) {
      let (argtype = prim("typeof", args["0"]))
      let (isArgObject = argtype === "object" || argtype === "function")
      let (isArgSomething = argtype === "boolean" ||
        argtype === "string" || argtype === "number")
      if (isArgObject) { args["0"] } else {
        if (isArgSomething) { %ToObject(args["0"]) } else { defaultRtn }
      }
    } else {
      defaultRtn
    }
  }
}



let [[%calllambda]] = func(this, args) {
    this(args["0"], %slice(args, 1, %len(args)))
}

let [[%call]] = { [#code : %calllambda,] }

let [[%functionToStringlambda]] = func(this, args) {
  "function ToString"
}

let [[%functionToString]] = 
{ [#code : %functionToStringlambda,] 
  "length" : {#value 0, #writable false} }

let [[%FunctionProto]] = { [#proto: %ObjectProto, #class : "Function",]
  "toString" : {#value %functionToString, #writable true},
  "call" : {#value %call, #writable false} }

 let [[%ObjectGlobalFuncObj]] = 
  { [#code : %ObjectConstructor, #proto : %FunctionProto,] 
    "prototype" : {#value %ObjectProto, #writable false},
    "length" : {#value 1, #writable false},
  }

 {%ObjectProto["constructor" = %ObjectGlobalFuncObj];
  %ObjectProto["constructor"<#enumerable> = false]}

let [[%FunctionConstructor]] = func(this, args) {
  let (argCount = args["length"])
  rec (formArgString = func(n, result) {
    if (n === argCount) {
      result
    } else {
      let (currentArg = %ToString(args[prim("prim->str", n)]))
      let (next = 
        if (n === prim("-", argCount, 1)) { 
          prim("+", result, currentArg)
        } else {
          prim("+", prim("+", result, currentArg), ",")
        })
      formArgString(prim("+", n, 1), next)
    }
  })
  let (body = 
    if (argCount === 0) { "" } else {
      args[prim("prim->str", prim("-", argCount, 1))]
    })
  let (P = if (argCount === 0 || argCount === 1) { "" }
    else { formArgString(0, "") })
  let (bodyF = func(this, args){ @eval(body) })
  { [#code : bodyF, #proto : %FunctionProto,] 
    "length" : {#value argCount, #writable false} }
}

let [[%FunctionGlobalFuncObj]] = 
  { [#code : %FunctionConstructor, #proto : %FunctionProto,] 
    "prototype" : {#value %FunctionProto, #writable false},
    "length" : {#value 0, #writable false}
  }

{%FunctionProto["constructor" = %FunctionGlobalFuncObj];
 %FunctionProto["constructor"<#enumerable> = false] }

let [[%objectToStringlambda]] = func(this, args) {
  let (O = %ToObject(this))
  let (class = prim("get-class", O))
  prim("string+", "[object ", prim("string+", class, "]"))
}

let [[%objectToString]] = 
  { [#code : %objectToStringlambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false} }

let [[%propEnumlambda]] = func(this, args) {
  let (getOwnProperty = func(o, f) {
    if (prim("hasOwnProperty", o, f)) { o[f] } else { undefined }})
  if (args["0"] === undefined) { false } else {
  let (P = %ToString(args["0"]))
  let (O = %ToObject(this))
  let (desc = getOwnProperty(O, P))
  if (desc === undefined) {
    false
  } else { 
    O[P<#enumerable>] 
  }}
}

let [[%propertyIsEnumerable]] = 
  {[#code : %propEnumlambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false} }

let [[%toLocaleStringlambda]] = func(this, args) {
  let (O = %ToObject(this))
  let (toString = O["toString"])
  if (prim("get-code", toString) === null) {
    throw { [#proto : %TypeErrorProto,] }
  } else {
    toString(O, {[]})
  }
}

let [[%toLocaleString]] = 
  { [#code : %toLocaleStringlambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false} }

let [[%valueOflambda]] = func(this, args) {
  %ToObject(this)
}

let [[%valueOf]] = 
  { [#code : %valueOflambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false}
  }


let [[%hasOwnPropertylambda]] = func(this, args) {
    if(prim("hasOwnProperty", this, args["0"])) {
      true
    }
    else {
      false
    }
}

let [[%hasOwnProperty]] = 
  { [#code : %hasOwnPropertylambda, #proto : %FunctionProto,] 
    "length" : {#value 1, #writable false}
  }


let [[%IsPrototypeOflambda]] = func(this, args) {
    rec (searchChain = func(o, v) {
      let (vproto = prim("get-proto", v))
      if (vproto === null) {
        false
      } else {
        if (o === vproto) {
          true
        } else {
          searchChain(o, vproto) 
        }
      }
    })
    let (vtype = prim("typeof", args["0"]))
    if (prim("!", vtype === "object") && prim("!", vtype === "function")) {
      false
    } else {
      let (O = %ToObject(this))
      searchChain(O, args["0"])
    }
}

let [[%isPrototypeOf]] = 
  { [#code : %IsPrototypeOflambda, #proto : %FunctionProto,]
    "length" : {#value 1, #writable false}
  }

{ %ObjectProto["toString" = %objectToString];
  %ObjectProto["toString"<#writable> = true];
  %ObjectProto["toString"<#enumerable> = false];

  %ObjectProto["toLocaleString" = %toLocaleString];
  %ObjectProto["toLocaleString"<#writable> = false];
  %ObjectProto["toLocaleString"<#enumerable> = false];

  %ObjectProto["valueOf" = %valueOf];
  %ObjectProto["valueOf"<#writable> = true];
  %ObjectProto["valueOf"<#enumerable> = false];

  %ObjectProto["hasOwnProperty" = %hasOwnProperty];
  %ObjectProto["hasOwnProperty"<#writable> = false];
  %ObjectProto["hasOwnProperty"<#enumerable> = false];

  %ObjectProto["isPrototypeOf" = %isPrototypeOf];
  %ObjectProto["isPrototypeOf"<#writable> = false];
  %ObjectProto["isPrototypeOf"<#enumerable> = false]
}

let [[%RETSlambda]] = func(this, args) {
  "RangeError"
}

let [[%REToString]] = 
  { [#code : %TETSlambda,] 
    "length" : {#value 0, #writable false} }

let [[%RangeErrorProto]] = { [#proto : %ObjectProto,] 
  "toString" : {#value %REToString, #writable false} }

let [[%RangeErrorConstructor]] = func(this, args) {
  { [#proto : %TypeErrorProto,] }
}

let [[%RangeErrorGlobalFuncObj]] = 
  { [#code : %RangeErrorConstructor, #proto : %RangeErrorProto,] 
    "prototype" : {#value %RangeErrorProto, #writable false} }

{%RangeErrorProto["constructor" = %RangeErrorGlobalFuncObj]}

let [[%ArrayProto]] = { [#proto : %ObjectProto, #class : "Array",] }

let [[%ToUint32]] = func(n) {
  let (number = %ToNumber(n))
  // TODO: check for Infinity
  if (number !== number || number === 0) { 0 } else {
    let (sign = if (prim("<", number ,0)) { prim("-", 0, 1) } else { 1 })
    let (posInt = prim("*", sign, prim("floor", prim("abs", number))))
    // 9.6.4:
    // Let int32bit be posInt modulo 2^32; that is, a finite integer value k of 
    // Number type with positive sign and less than 2^32 in magnitude such that 
    // the mathematical difference of posInt and k is mathematically an integer
    // multiple of 2^32.
    // return int32bit
    if (prim("<", sign, 0)) {
      let (close = prim("%", posInt, 4294967296.0))
      prim("+", close, 4294967296.0)
    } else { 
      prim("%", posInt, 4294967296.0)
    }
  }
}

let [[%joinlambda]] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (sep = if (args["0"] === undefined) { "," } 
    else { %ToString(args["0"]) })
  label ret:
  if (len === 0) {
    break ret ""
  } else { null };
  rec (loop = func(k, R) {
    if (prim(">=", k, len)) {
      R
    } else {
      let (S = prim("string+", R, sep))
      let (element = O[%ToString(k)])
      let (next =
        if (element === null || element === undefined) { "" }
        else { %ToString(element) })
      loop(prim("+", k, 1), prim("string+", S, next)) 
    }
  })
  let (start = if (O["0"] === undefined || O["0"] === null) { "" }
    else { %ToString(O["0"]) })
  break ret loop(1, start)
}

let [[%join]] = { [#code : %joinlambda, #proto : %FunctionProto,] }

{%defineOwnProperty(%join, 
    "length", 
    {[] "value" : {#value 1, #writable true}, 
        "configurable" : {#value false, #writable true},
        "enumerable" : {#value false, #writable true}})}

let [[%poplambda]] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  if (len === 0) {
    O["length" = 0];
    undefined
  } else {
    let (indx = %ToString(prim("-", len, 1)))
    let (element = O[indx])
    O[delete indx];
    O["length" = %ToNumber(indx)];
    element
  }
}

let [[%pop]] = { [#code : %poplambda, #proto : %FunctionProto,] }

{%defineOwnProperty(%pop,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}})}

{%defineOwnProperty(%ArrayProto,
  "pop",
  {[] "value" : {#value %pop, #writable true},
      "configurable" : {#value true, #writable true}})}

let [[%pushlambda]] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  rec (loop = func(i, n) {
    if (prim("<", i, args["length"])) {
      let (ii = prim("prim->str", i))
      O[%ToString(n) = args[ii] ];
      loop(prim("+", i, 1), prim("+", n, 1))
    } else { n }
  })
  let (result = loop(0, len))
  if (prim("get-class", O) === "Array") {
    let (c1 = %ToNumber(result))
    let (c2 = %ToUint32(result))
    if (c1 === c2) {
      O["length" = result]
    } else {
      throw {[#proto : %RangeErrorProto,]}
    }
  } else {
    O["length" = result]
  }
}

let [[%push]] = {[#code : %pushlambda, #proto : %FunctionProto,]}

{%defineOwnProperty(%push,
  "length",
  {[] "value" : {#value 1, #writable true},
      "configurable" : {#value false, #writable true}})}

{%defineOwnProperty(%ArrayProto,
  "push",
  {[] "value" : {#value %push, #writable true},
      "configurable" : {#value true, #writable true}})}


let [[%ArrayLengthChange]] = func(arr, n) {
  let (oldlen = %ToUint32(arr["length"]))
  let (newlen = prim("prim->num", n))
  rec (fix = func(i) {
    if (prim("<", i, oldlen)) {
      arr[delete prim("prim->str", i)];
      fix(prim("+", i, 1))
    }
  })
  fix(newlen)
}

let [[%reverselambda]] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (middle = prim("floor", prim("/", len, 2)))
  rec (loop = func(lower) {
    if (lower !== middle) {
      label ret:
      let (upper = prim("-", prim("-", len, lower), 1))
      let (upperP = %ToString(upper))
      let (lowerP = %ToString(lower))
      let (lowerValue = O[lowerP])
      let (upperValue = O[upperP])
      let (lowerExists = prim("hasProperty", O, lowerP))
      let (upperExists = prim("hasProperty", O, upperP))

      if (lowerExists && upperExists) {
        O[lowerP = upperValue];
        O[upperP = lowerValue];
        break ret loop(prim("+", lower, 1))
      } else { null };

      if (upperExists) {
        O[lowerP = upperValue];
        O[delete upperP];
        break ret loop(prim("+", lower, 1))
      } else { null };

      if (lowerExists) {
        O[delete lowerP];
        O[upperP = lowerValue];
        break ret loop(prim("+", lower, 1))
      } else { null };

      break ret loop(prim("+", lower, 1))
    }
  })
  loop(0);
  O
}

let [[%reverse]] = {[#code : %reverselambda, #proto : %FunctionProto,]}

{ %defineOwnProperty(%reverse,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
  "reverse",
  {[] "value" : {#value %reverse, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [[%shiftlambda]] = func(this, args) {
  let (O = %ToObject(this))
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  if (len === 0) {
    O["length" = 0];
    undefined
  } else { 
    let (first = O["0"])
    rec (loop = func(k) {
      label ret:
      if (prim(">=", k, len)) {
        break ret undefined
      } else { null };

      let (from = %ToString(k))
      let (to = %ToString(prim("-", k, 1)))
      let (fromPresent = prim("hasProperty", O, from))
      if (fromPresent) {
        let (fromVal = O[from])
        O[to = fromVal];
        break ret loop(prim("+", k, 1))
      } else {
        O[delete to];
        break ret loop(prim("+", k, 1))
      }
    })
    loop(1);
    let (newLen = prim("-", len, 1))
    O[delete %ToString(newLen)];
    O["length" = newLen];
    first
  }
}

let [[%shift]] = {[#code : %shiftlambda, #proto : %FunctionProto,]}

{ %defineOwnProperty(%shift,
  "length",
  {[] "value" : {#value 0, #writable true},
      "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
  "shift",
  {[] "value" : {#value %shift, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [[%arrayToStringlambda]] = func(this, args) {
  let (array = %ToObject(this))
  let (thefunc = array["join"])
  let (ffunc = 
  if (prim("!", prim("typeof", thefunc) === "object") &&
      prim("!", prim("typeof", thefunc) === "function")) {
    %objectToStringlambda
  } else {
    if (prim("get-code", thefunc) === null) {
      %objectToStringlambda
    } else { thefunc }
  })
  ffunc(array, {[]})
}

let [[%arrayToString]] = 
  { [#code : %arrayToStringlambda, #proto : %FunctionProto,] 
    "length" : {#value 0, #writable false} }

{ %defineOwnProperty(%ArrayProto, 
    "toString", 
    {[] "value" : {#value %arrayToString, #writable true}, 
        "configurable" : {#value true, #writable true}});
  %defineOwnProperty(%ArrayProto,
    "join",
    {[] "value" : {#value %join, #writable true},
        "configurable" : {#value true, #writable true}}) }

let [[%arrayTLSlambda]] = func(this, args) {
  let (isCallable = func(o) {
    label ret:
    if (prim("!", prim("typeof", o) === "object") &&
        prim("!", prim("typeof", o) === "function")) {
      break ret false 
    } else { null };
    if (prim("get-code", o) === null) {
      break ret false
    } else { null };
    break ret true
  })
  let (array = %ToObject(this))
  let (arrayLen = array["length"])
  let (len = %ToUint32(arrayLen))
  let (separator = " ")
  label ret:
  if (len === 0) {
    break ret ""
  } else { null };
  let (firstElement = array["0"])
  let (R = if (firstElement === null || firstElement === undefined) { "" } else {
    let (elementObj = %ToObject(firstElement))
    let (funcc = elementObj["toLocaleString"])
    if (prim("!", isCallable(funcc))) {
      throw {[#proto : %TypeErrorProto,]}
    } else { null };
    funcc(elementObj, {[]}) })
    rec (inner = func(k, r) {
      if (prim(">=", k, len)) {
        r
      } else {
        let (S = prim("string+", prim("prim->str", r), separator))
        let (nextElement = array[prim("prim->str", k)])
        let (toAppend = if (nextElement === null ||
          nextElement === undefined) { "" } else {
          let (elementObj = %ToObject(nextElement))
          let (funcc = elementObj["toLocaleString"])
          if (prim("!", isCallable(funcc))) {
            throw {[#proto : %TypeErrorProto,]}
          } else { null };
          funcc(elementObj, {[]}) })
          inner(prim("+", k, 1), 
            prim("string+", prim("prim->str", r),
            prim("prim->str", toAppend)))
      }
    })
    break ret inner(1, R)
}

let [[%arrayToLocaleString]] = 
  { [#code : %arrayTLSlambda, #proto : %FunctionProto,]
    "length" : {#value 0, #writable false} }

{ %defineOwnProperty(%ArrayProto, 
    "toLocaleString", 
    {[] "value" : {#value %arrayToLocaleString, #writable true}, 
        "configurable" : {#value true, #writable true}}) }

let [[%ArrayConstructor]] = func(this, args) {
  label ret:
  if (prim(">=", args["length"], 2)) {
    let (rtnobj = 
      {[#proto : %ArrayProto, #class : "Array",] 
        "length" : {#value 0, #writable true}, })
    rec (init = func(n) {
      rtnobj[ prim("prim->str", n) = args[prim("prim->str", n)] ];
      if (prim(">", n, 0)) {
        init(prim("-", n, 1))
      }
    })
    init(args["length"]);
    rtnobj["length" = args["length"] ];
    break ret rtnobj
  } else { null };
  let (c1 = prim("typeof", args["0"]) === "number")
  let (c2 = if (c1) { %ToUint32(args["0"]) !== args["0"] } else { false })
  if (c2) {
    throw {[#proto : %RangeErrorProto,]}
  } else {
    if (c1) {
      break ret { [#proto : %ArrayProto, #class : "Array",]
        "length" : {#value %ToUint32(args["0"]), #writable true} }
    } else {
      break ret {[#proto : %ArrayProto, #class : "Array",]
        "length" : {#value args["length"], #writable true},
        "0" : {#value args["0"], #writable true} }
    }
  }
}

let [[%concatLambda]] = func(this, args) {
  let (O = %ToObject(this))
  let (emptyobj = {[]})
  let (A = %ArrayConstructor(emptyobj, emptyobj))
  rec (procElt = func(obj, elt, n) {
    let (procNormalElt = func(nelt, k) {
      obj[prim("prim->str", k) = nelt];
      prim("+", k, 1)
    })
    rec (procArrayElt = func(arr, fromIndex, toIndex) {
      if (arr[prim("prim->str", fromIndex)] === undefined) {
        toIndex
      } else {
        obj[prim("prim->str", toIndex) = arr[prim("prim->str", fromIndex)] ];
        procArrayElt(arr, prim("+", fromIndex, 1), prim("+", toIndex, 1))
      }
    })
    if (prim("typeof", elt) === "object") {
      if (prim("get-class", elt) === "Array") {
        procArrayElt(elt, 0, n)
      } else {
        procNormalElt(elt, n)
      }
    } else {
      procNormalElt(elt, n)
    }
  })
  rec (procAllElts = func(from, fromIndex, toIndex) {
    if (from[prim("prim->str", fromIndex)] !== undefined) {
      let (nextI = procElt(A, from[prim("prim->str", fromIndex)], toIndex))
      procAllElts(from, prim("+", fromIndex, 1), nextI)
    } else { toIndex }
  })
  let (halftime = if (prim("get-class", O) === "Array") {
    procAllElts(O, 0, 0) } else { A["0" = O]; 1 })
  let (end = procAllElts(args, 0, halftime))
  A["length" = end];
  A
}

let [[%concat]] = 
  { [#code : %concatLambda, #proto : %FunctionProto,] }

{ %defineOwnProperty(%concat,
    "length",
    {[] "value" : {#value 1, #writable true},
        "enumerable" : {#value false, #writable true}})}

{ %defineOwnProperty(%ArrayProto,
    "concat",
    {[] "value" : {#value %concat, #writable true}})}

let [[%sortlambda]] = func(this, args) {
  let (obj = %ToObject(this))
  let (sortCompare = func(j, k) {
    let (jString = %ToString(j))
    let (kString = %ToString(k))

    let (hasj = prim("hasProperty", obj, jString))
    let (hask = prim("hasProperty", obj, kString))
    label ret:
    if (hasj === false && hask === false) {
      break ret 0
    } else { null };

    if (hasj === false) {
      break ret 1
    } else { null };

    if (hask === false) {
      break ret prim("-", 0, 1)
    } else { null };

    let (x = obj[jString])
    let (y = obj[kString])
    if (x === undefined && y === undefined) {
      break ret 0
    } else { null };

    if (x === undefined) {
      break ret 1
    } else { null };

    if (y === undefined) {
      break ret prim("-", 0, 1)
    } else { null };

    if (args["0"] !== undefined) {
      if (prim("typeof", args["0"]) !== "function") {
        throw {[#proto : %TypeErrorProto,]}
      } else { null };

      break ret args["0"](undefined, 
        {[] "0" : {#value x, #writable true},
            "1" : {#value y, #writable true}})
    } else { null };

    let (xString = %ToString(x))
    let (yString = %ToString(y))

    if (prim("string<", xString, yString)) {
      break ret prim("-", 0, 1)
    } else { null };

    if (prim("string<", yString, xString)) {
      break ret 1
    } else { null };

    break ret 0
  })

  let (insert = func(elt, before) {
    rec (insertAndShift = func(prior, i) {
      let (indx = prim("prim->str", i))
      let (next = obj[indx])
      obj[indx = prior];
      if (prim("<", i, before)) {
        insertAndShift(next, prim("+", i, 1))
      } else { undefined }
    })

    rec (loop = func(currIndex) {
      if (currIndex === before) {
        // elt can stay where it was
        undefined
      } else {
        let (indx = prim("prim->str", currIndex))
        //let (result = sortCompare(obj[indx], elt))
        let (result = sortCompare(currIndex, before))
        //let (result = if (prim("<", obj[indx], elt)) { 0 } else { 1 })
        if (result === 1) {
          let (old = obj[indx])
          obj[indx = elt];
          insertAndShift(old, prim("+", currIndex, 1))
        } else {
          loop(prim("+", currIndex, 1))
        }
      }
    })

    loop(0)
  })

  let (len = obj["length"])
  rec (isort = func(i) {
    if (prim("<", i, len)) {
      insert(obj[prim("prim->str", i)], i);
      isort(prim("+", i, 1))
    } else { undefined }
  })

  isort(1)
}

let [[%sort]] = { [#code : %sortlambda, #proto : %FunctionProto,] }

{%defineOwnProperty(%sort,
  "length",
  {[] "value" : {#value 1, #writable true},
      "enumerable" : {#value false, #writable true}}) }

{%defineOwnProperty(%ArrayProto,
  "sort",
  {[] "value" : {#value %sort, #writable true},
      "configurable" : {#value true, #writable true}}) }

let [[%ArrayGlobalFuncObj]] = 
  { [#code : %ArrayConstructor, #proto : %FunctionProto, #class : "Function",] 
    "prototype" : {#value %ArrayProto, #writable false} }

{ %ArrayGlobalFuncObj["length" = 1];
  %ArrayGlobalFuncObj["length"<#enumerable> = false];
  %ArrayGlobalFuncObj["length"<#configurable> = false];
  %defineOwnProperty(%ArrayProto,
      "constructor",
      {[] "value" : {#value %ArrayGlobalFuncObj, #writable true},
          "configurable" : {#value true, #writable true},
          "enumerable" : {#value false, #writable true}}) }

let [[%getCurrentUTC]] = func() { 0 } // TODO: implement

let [[%parse]] = func(v) { 0 } // TODO: implement

let [[%TimeClip]] = func(v) { 0 } // TODO: implement

let [[%ToInteger]] = func(i) { 
  label ret:
  let (number = %ToNumber(i))
  if (number !== number) {
    break ret 0
  } else { null };
  // TODO: this should check for +Infinity or -Infinity as well
  if (number === 0) { 
    break ret number
  } else { null };
  // Why 0 - 1? No negative number literals (yet)
  let (sign = if (prim("<", number, 0)) { prim("-", 0, 1) } else { 1 })
  let (a = prim("abs", number))
  let (f = prim("floor", a))
  let (r = prim("*", sign, f))
  break ret r
}

let [[%slicelambda]] = func(this, args) {
  let (O = %ToObject(this))
  let (A = {[#proto : %ArrayProto, #class : "Array",]})
  let (lenVal = O["length"])
  let (len = %ToUint32(lenVal))
  let (relativeStart = %ToInteger(args["0"]))

  let (initk = if (prim("<", relativeStart, 0)) {
    let (added = prim("+", len, relativeStart))
    if (prim(">", added, 0)) { added } else { 0 }
    } else {
      if (prim("<", relativeStart, len)) { relativeStart } else { len }
    })

  let (relativeEnd = if (args["1"] === undefined) { len } 
    else { %ToInteger(args["1"]) })

  let (final = if (prim("<", relativeEnd, 0)) {
    let (added = prim("+", len, relativeEnd))
    if (prim(">", added, 0)) { added } else { 0 }
  } else {
    if (prim("<", relativeEnd, len)) { relativeEnd } else { len }
  })

  rec (loop = func(n, k, finalLen) {
    label ret:
    if (prim(">=", k, final)) {
      break ret finalLen
    } else { null };

    let (Pk = %ToString(k))
    let (kPresent = prim("hasProperty", O, Pk))
    if (kPresent) {
      let (kValue = O[Pk])
      %defineOwnProperty(A,
        %ToString(n),
        {[] "value" : {#value kValue, #writable true},
            "writable" : {#value true, #writable true},
            "configurable" : {#value true, #writable true},
            "enumerable" : {#value true, #writable true}});
      break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
    } else {
      break ret loop(prim("+", n, 1), prim("+", k, 1), prim("+", finalLen, 1))
    }
  })

  A["length" = loop(0, initk, 0)];
  A
}

let [[%slice]] = {[#code : %slicelambda, #proto : %FunctionProto,]}

{ %defineOwnProperty(%slice,
    "length",
    {[] "value" : {#value 2, #writable true},
        "configurable" : {#value false, #writable true}}) }

{ %defineOwnProperty(%ArrayProto,
    "slice",
    {[] "value" : {#value %slice, #writable true},
        "configurable" : {#value true, #writable true}}) }

let [[%numToStringAbstract]] = func(n, r) {
  label ret:
  if (r === 10) {
    break ret prim("prim->str", n)
  } else { null };
  break ret prim("base", n, r)
}

let [[%numberToStringlambda]] = func(this, args) {
  let (radix = if (args["0"] === undefined) { 10 } else { %ToInteger(args["0"]) })
  let (rint = %ToInteger(radix))
  if (rint === 10) {
    %numToStringAbstract(prim("get-primval", this), 10)
  } else {
    if (prim("!", prim("typeof", rint) === "number")) {
      throw "RangeError"
    } else {
      if (prim("<", rint, 2) || prim(">", rint, 36)) {
        throw "RangeError"
      } else {
        %numToStringAbstract(prim("get-primval", this), rint)
      }
    }
  }
}

let [[%numberToString]] = 
  { [#code : %numberToStringlambda,] 
    "length" : {#value 0, #writable false} }

{%NumberProto["toString" = %numberToString]}

let [[%StringIndexOflambda]] = func(this, args) {
  let (min = func(a, b) { if (prim("<", a, b)) { a } else { b } })
  let (max = func(a, b) { if (prim(">", a, b)) { a } else { b } })
  let (S = %ToString(this))
  let (searchStr = %ToString(args["0"]))
  let (pos = %ToInteger(args["1"]))
  let (len = prim("strlen", S))
  let (start = min(max(pos, 0), len))
  let (searchLen = prim("strlen", searchStr))
  let (obj = 
    { [] "0" : {#value start, #writable false}, 
      "1" : {#value searchLen, #writable false},
      "2" : {#value len, #writable false},
      "3" : {#value S, #writable false},
      "4" : {#value searchStr, #writable false} 
    })
  prim("indexofhelper", obj)
}

let [[%StringIndexOf]] = { [#code : %StringIndexOflambda, #proto : %FunctionProto,]}

{%StringProto["indexOf" = %StringIndexOf]}

let [[%MakeDate]] = func(day, time) { 0 } // TODO: implement

let [[%MakeDay]] = func(yr, mt, dt) { 0 } // TODO: implement

let [[%MakeTime]] = func(h, min, s, milli) { 0 } // TODO: implement

let [[%UTC]] = func(v) { 0 } // TODO: implement

let [[%getYearlambda]] = func(this, args) { 78 } // TODO: implement

let [[%getYear]] = { [#code : %getYearlambda,] }

let [[%getMonthlambda]] = func(this, args) { 3 } // TODO: implement

let [[%getMonth]] = { [#code: %getMonthlambda,] }

let [[%DateProto]] = { 
  [#proto : %ObjectProto,]
  "getYear" : {#value %getYear, #writable false},
  "getMonth": {#value %getMonth, #writable false},
}

let [[%DateConstructor]] = func(this, args) {
  let (calledAsFunction = this === %global)
  let (nargs = args["length"])
  if (nargs === "0") {
    let (v = %getCurrentUTC())
    { [#proto : %DateProto, #class : "Date", #extensible : true, #value : v,] }
  } else {
    if (nargs === "1") {
      let (v = %ToPrimitive(args["0"]))
      let (V =
        if (prim("typeof", v) === "string") { %parse(v) } else { %ToNumber(v) })
      let (clipped = %TimeClip(V))
      { [#proto : %DateProto, #class : "Date", #extensible : true, #value : clipped,] }
    } else {
      let (y = %ToNumber(args["0"]))
      let (m = %ToNumber(args["1"]))
      let (dt = if (args["2"] === undefined) { 1 } else { %ToNumber(args["2"]) })
      let (h = if (args["3"] === undefined) { 0 } else { %ToNumber(args["3"]) })
      let (min = if (args["4"] === undefined) { 0 } else { %ToNumber(args["4"]) })
      let (s = if (args["5"] === undefined) { 0 } else { %ToNumber(args["5"]) })
      let (milli = if (args["6"] === undefined) { 0 } else { %ToNumber(args["6"]) })
      let (yr = 
        let (tiy = %ToInteger(y))
        let (rangecond1 = prim("<", 0, tiy) || 0 === tiy)
        let (rangecond2 = prim("<", tiy, 99) || tiy === 99)
        if (y !== y && rangecond1 && rangecond2) {
          prim("+", 1900, tiy) } else { y })
      let (finalDate = %MakeDate(%MakeDay(yr, m, dt), %MakeTime(h, min, s, milli)))
      let (primval = %UTC(%TimeClip(finalDate)))
      { [#proto : %DateProto, #class : "Date", #extensible : true, #value : primval,] }
    }
  }
}

let [[%DateGlobalFuncObj]] = { [#code : %DateConstructor, #proto : %DateProto,] }

let [[%testlambda]] = func(this, args) {
  prim("print", "test")
}

let [[%test]] = { [#code : %testlambda,] }

let [[%RegexpProto]] = { []
  "test" : {#value %test, #writable false} }


let [[%parseIntlambda]] = func(n) {
  undefined
}

let [[%parseInt]] = { [#code : %parseIntlambda,] }

let [[%explambda]] = func() {
  undefined
}

let [[%exp]] = { [#code : %explambda,] }

let [[%Math]] = { []
  "exp" : {#value %exp, #writable false} }

let [[%PrimAdd]] = func(l, r) {
    let (l = %ToPrimitive(l))
    let (r = %ToPrimitive(r))
  if (prim("stx=", prim("typeof", l), "string")) {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else if (prim("stx=", prim("typeof", r), "string")) {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else {
    let (lnum = prim("prim->num", l))
    let (rnum = prim("prim->num", r))
    prim("+", lnum, rnum)
  }
}

let [[%PrimSub]] = func(l, r) {
    let (l = %ToPrimitiveHint(l, "number"))
    let (r = %ToPrimitiveHint(r, "number"))
    prim("-", l, r)
}

{
  %global["print" = %print];
  %global["Array" = %ArrayGlobalFuncObj];
  %global["String" = %StringGlobalFuncObj];
  %global["Object" = %ObjectGlobalFuncObj];
  %global["Number" = %NumberGlobalFuncObj];
  %global["Boolean" = %BooleanGlobalFuncObj];
  %global["Date" = %DateGlobalFuncObj];
  %global["Function" = %FunctionGlobalFuncObj];
  %global["isNaN" = %isNaN];
  %global["Math" = %Math];
  %global["parseInt" = %parseInt];
  %global["TypeError" = %TypeErrorGlobalFuncObj];
  %global["RangeError" = %RangeErrorGlobalFuncObj];

  %ObjectProto["propertyIsEnumerable" = %propertyIsEnumerable];
  %ObjectProto["propertyIsEnumerable"<#enumerable> = false];

  %ObjectProto["defineProperty" = %defineProperty];
  %ObjectProto["defineProperty"<#enumerable> = false]
}

let [[%context]] = %global

let [[%evallambda]] = func(this, args) {
    @eval(args["0"])
}

let [[%eval]] = { [#code : %evallambda,] }

{%global["eval" = %eval];
 %global["eval"<#enumerable> = false]}

let [[%this]] = %global
