let [[%StringProto]] = undefined

let [[%neginf]] = 0

let [[%NumberProto]] = { []
  "NEGATIVE_INFINITY" : {#value %neginf, #writable false},
}

let [[%instanceof]] = func(o1, o2) {
    if(typeof o1 !== "object") {
      throw "TypeError"
    }
    else {
      let (o2prototype = o2["prototype"])
      let (o1proto = prim("get-proto", o1))
      rec (instanceof = func(currproto) {
        if(currproto === null) {
           false
        }
        else {
          if(currproto === o1proto) {
            true
          }
          else {
            instanceof(prim("get-proto", currproto))
          }
        }
      })
      instanceof(o2prototype)
    }
}


let [[%ToObject]] = func (o) {
    label ret : 
    let (t = prim("surface-typeof", o))
    if (t === "object" || t === "function") {
       break ret o
    }
    else { null };
    if (t === "string") {
       break ret
       {[#class: "String", 
         #extensible: true,
         #proto: %StringProto,
         #value: o,]}
    }
    else { null };
    if (t === "number") {
       break ret
       {[#class: "Number",
         #extensible: true,
         #proto: %NumberProto,
         #value: o,]}
    }
    else { null };
    throw t
}


let [[%ToPrimitiveNum]] = func(obj) {
    label ret :
    let (valueOf = obj["toString"])
    if (prim("typeof", valueOf) === "function") {
        let (str = valueOf(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    let (valueOf = obj["toString"])
    if (prim("typeof", toString) === "function") {
        let (str = toString(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    throw "TypeError exception some day"
}

let [[%ToPrimitiveStr]] = func(obj) {
    label ret :
    let (toString = obj["toString"])
    if (prim("typeof", toString) === "function") {
        let (str = toString(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    let (valueOf = obj["valueOf"])
    if (prim("typeof", valueOf) === "function") {
        let (str = valueOf(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    throw "TypeError exception some day"
}

let [[%ToPrimitiveHint]] = func(val, hint) {
    let (t = prim("typeof", val))
    if(t === "function" || t === "object") {
        if(hint === "string") {
            %ToPrimitiveStr(val)
        }
        else {
            %ToPrimitiveNum(val)
        }
    }
    else {
        val
    }
}

let [[%ToPrimitive]] = func(val) {
    // TODO exception for date objects
    %ToPrimitiveHint(val, "number")
}

let [[%ToString]] = func(val) {
    prim("prim->str", %ToPrimitiveHint(val, "string"))
}

let [[%ToNumber]] = func(val) {
    prim("prim->num", %ToPrimitiveHint(val, "number"))
}

let [[%isNaNlambda]] = func(this, args) {
    args["0"] !== args["0"]
}

// 11.9.3
let [[%EqEq]] = rec (eqeq = func(x1, x2) {
    label ret :
    let (t1 = prim("typeof", x1))
    let (t2 = prim("typeof", x2))
    if(t1 === t2) {
      if(t1 === "undefined") {
          break ret true
      }
      else {
          if(t1 === "null") {
              break ret true }
          else {
              if(t1 === "number") {
                  break ret (x1 === x2) }
              else {
                  if(t1 === "string") {
                      break ret (x1 === x2) }
                  else {
                      if(t1 === "object") {
                          break ret (x1 === x2) }
                      else {
                          throw "[env] Catastrophe---unknown type in ==" }
                  }}}}}
    else {
        if((x1 === undefined && x2 === null) ||
           (x1 === null && x2 === undefined)) {
            break ret true }
        else {
            if(t1 === "number" && t2 === "string") {
                break ret (x1 === prim("prim->num", x2)) }
            else {
                if(t1 === "string" && t2 === "number") {
                    break ret (prim("prim->num", x1) === x2) }
                else {
                    if(t1 === "boolean" || t2 === "boolean") {
                        break ret (prim("prim->num", x1) === prim("prim->num", x2)) }
                    else {
                        if((t1 === "string" || t1 === "number") &&
                           (t2 === "object")) {
                            break ret eqeq(x1, %ToPrimitive(x2)) }
                        else {
                            if((t2 === "string" || t2 === "number") &&
                               (t1 === "object")) {
                                break ret eqeq(%ToPrimitive(x1), x1) }
                            else {
                                break ret false }
                        }}}}}}}) eqeq
    

let [[%isNaN]] = { [#code : %isNaNlambda,] }

let [[%printlambda]] = func(o, s) {
    prim("print", %ToString(s["0"]))
}

let [[%print]] = { [#code : %printlambda,] }

let [[%toStringlambda]] = func(this, args) {
    undefined
}

let [[%toString]] = { [#code : %toStringlambda,] }

let [[%len]] = func(list) {
    rec (inner_len = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                prim("+", 1, inner_len(prim("+", 1, iter)))
            }
            else { iter }
        })
    inner_len(0)
}

let [[%slice]] = func(list, min, max) {
    let (retObj = {[#extensible: true,]})
    rec (inner_slice = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                retObj[prim("prim->str", iter) = list[prim("prim->str", iter)] ];
                if(prim(">", iter, max)) { undefined }
                else { inner_slice(prim("+", iter, 1)) }
            }
            else { undefined }
        })
    inner_slice(min);
    retObj
}

let [[%hasOwnPropertylambda]] = func(this, args) {
  prim("print", "hasOwnProperty")
}

let [[%hasOwnProperty]] = { [#code : %hasOwnPropertylambda,] }

let [[%getOwnPropertyDescriptorlambda]] = func(this, args) {
  prim("print", "getOwnPropertyDescriptor")
}

let [[%getOwnPropertyDescriptor]] = { [#code : %getOwnPropertyDescriptorlambda,] }

let [[%IsPrototypeOflambda]] = func(this, args) {
    let (protoobj = prim("get-proto", args["0"]))
    protoobj === this
}

let [[%isPrototypeOf]] = { [#code : %IsPrototypeOflambda,] }

let [[%ObjectProto]] = { [] 
  "toString" : {#value %toString, #writable false},
  "hasOwnProperty" : {#value %hasOwnProperty, #writable false},
  "getOwnPropertyDescriptor" : {#value %getOwnPropertyDescriptor, #writable false},
  "isPrototypeOf" : {#value %isPrototypeOf, #writable false}
 }


let [[%calllambda]] = func(this, args) {
    this(args["0"], %slice(args, 1, %len(args)))
}

let [[%call]] = { [#code : %calllambda,] }

    let [[%FunctionProto]] = { [#proto: %ObjectProto,]
  "toString" : {#value %toString, #writable false},
  "call" : {#value %call, #writable false} }

let [[%pushlambda]] = func(this, args) {
  this[ prim("prim->str", this["length"]) = args["0"] ];
  this[ "length" = prim("+", this["length"], 1) ]
}

let [[%push]] = { [#code : %pushlambda,] }


let [[%sortlambda]] = func(this, args) {
    undefined
}

let [[%sort]] = { [#code : %sortlambda,] }

let [[%joinlambda]] = func(this, args) {
    let (list = this)
    let (separator = 
      if (prim("hasOwnProperty", args, prim("prim->str", 0))) {
        args[prim("prim->str", 0)]
      } else {
        ","
      })
    rec (inner_join = func(n, result) {
      if (prim("abs=", n, 0)) {
        prim("string+", %ToString(list[prim("prim->str", n)]), result) 
      } else {
        let (element = %ToString(list[prim("prim->str", n)]))
        let (next = 
        prim("string+", separator, prim("string+", element, result)))
        inner_join(prim("-", n, 1), next)
      }
    })
    let (start = prim("-", prim("prim->num", this["length"]), 1))
    inner_join(start, "")
}

let [[%join]] = { [#code : %joinlambda,] }

let [[%ArrayProto]] = { [] 
  "toString" : {#value %toString, #writable false},
  "push" : {#value %push, #writable false}, 
  "sort" : {#value %sort, #writable false},
  "join" : {#value %join, #writable false} }

let [[%ArrayConstructor]] = func(this, args) {
  let (rtnobj = { [#proto : %ArrayProto,] "length" : {#value 0, #writable true}, })
  rec (init = func(n) {
    rtnobj[ prim("prim->str", n) = args[prim("prim->str", n)] ];
    if (prim(">", n, 0)) {
      init(prim("-", n, 1))
    }
  })
  init(args["length"]);
  rtnobj["length" = args["length"] ];
  rtnobj
}

let [[%ArrayGlobalFuncObj]] = { [#code : %ArrayConstructor, #proto : %ArrayProto,] }


let [[%BooleanProto]] = { [] }

let [[%BooleanConstructor]] = func(this, args) {
  { [#proto : %BooleanProto,] }
}

let [[%BooleanGlobalFuncObj]] = { [#code : %BooleanConstructor, #proto : %BooleanProto,] }

let [[%replacelambda]] = func(this, args) {
    undefined
}

let [[%replace]] = { [#code : %replacelambda,] }

let [[%StringProto]] = { [] 
  "toString" : {#value %toString, #writable false},
  "replace" : {#value %replace, #writable false} }

let [[%testlambda]] = func(this, args) {
  prim("print", "test")
}

let [[%test]] = { [#code : %testlambda,] }

let [[%RegexpProto]] = { []
  "test" : {#value %test, #writable false} }

let [[%ToBoolean]] = func(x) {
  prim("prim->bool", x)
//  if (prim("stx=", prim("typeof", x), "Object")) {
//    true
//  } else {
//    prim("prim->bool", x)
//  }
}

let [[%parseIntlambda]] = func(n) {
  undefined
}

let [[%parseInt]] = { [#code : %parseIntlambda,] }

let [[%explambda]] = func() {
  undefined
}

let [[%exp]] = { [#code : %explambda,] }

let [[%Math]] = { []
  "exp" : {#value %exp, #writable false} }
  

let [[%PrimAdd]] = func(l, r) {
    let (l = %ToPrimitive(l))
    let (r = %ToPrimitive(r))
  if (prim("stx=", prim("typeof", l), "string")) {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else if (prim("stx=", prim("typeof", r), "string")) {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else {
    prim("print", prim("typeof", l));
    let (lnum = prim("prim->num", l))
    let (rnum = prim("prim->num", r))
    prim("+", lnum, rnum)
  }
}

let [[%PrimSub]] = func(l, r) {
    let (l = %ToPrimitiveHint(l, "number"))
    let (r = %ToPrimitiveHint(r, "number"))
    prim("-", l, r)
}

let [[%global]] = { [] 
  "print" : {#value %print, #writable false}, 
  "Array" : {#value %ArrayGlobalFuncObj, #writable false},
  "String" : {#value %StringProto, #writable false},
  "Object" : {#value %ObjectProto, #writable false},
  "Number" : {#value %NumberProto, #writable false},
  "Boolean" : {#value %BooleanGlobalFuncObj, #writable false},
  "Function" : {#value %FunctionProto, #writable false},
  "isNaN" : {#value %isNaN, #writable false },
  "Math" : {#value %Math, #writable false },
  "parseInt" : {#value %parseInt, #writable false}
}

let [[%context]] = %global

let [[%evallambda]] = func(this, args) {
    @eval(args["0"])
}

let [[%eval]] = { [#code : %evallambda,] }

{%global["eval" = %eval]}
