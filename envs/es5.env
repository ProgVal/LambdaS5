let [[%global]] = { [] }

let [[%Object]] = {[]}

let [[%neginf]] = 0

let [[%hasOwnPropertylambda]] = func(this, args) {
    if(prim("hasOwnProperty", this, args["0"])) {
      true
    }
    else {
      false
    }
}

let [[%hasOwnProperty]] = { [#code : %hasOwnPropertylambda,] }

let [[%getOwnPropertyDescriptorlambda]] = func(this, args) {
  prim("print", "getOwnPropertyDescriptor")
}

let [[%getOwnPropertyDescriptor]] = { [#code : %getOwnPropertyDescriptorlambda,] }

let [[%IsPrototypeOflambda]] = func(this, args) {
    let (protoobj = prim("get-proto", args["0"]))
    protoobj === this
}

let [[%isPrototypeOf]] = { [#code : %IsPrototypeOflambda,] }



let [[%toLocaleStringlambda]] = func(this, args) {
  undefined
}

let [[%toLocaleString]] = { [#code : %toLocaleStringlambda,] }


let [[%ObjectProto]] = { [] 
  "hasOwnProperty" : {#value %hasOwnProperty, #writable false},
  "getOwnPropertyDescriptor" : {#value %getOwnPropertyDescriptor, #writable false},
  "isPrototypeOf" : {#value %isPrototypeOf, #writable false},
  "toLocaleString" : {#value %toLocaleString, #writable false},
 }

let [[%booleanToStringlambda]] = func(this, args) {
  "boolean toString"
}

let [[%booleanToString]] = { [#code : %booleanToStringlambda,] }

let [[%BooleanProto]] = { [#proto : %ObjectProto,]
  "toString" : {#value %booleanToString, #writable false}, 
}


let [[%BooleanConstructor]] = func(this, args) {
  let (pb = prim("prim->bool", args["0"]))
  { [#value : pb, #proto : %BooleanProto,] }
}

let [[%BooleanGlobalFuncObj]] = { [#code : %BooleanConstructor, #proto : %BooleanProto,] }

{%BooleanProto["constructor" = %BooleanGlobalFuncObj]}

let [[%numberToStringlambda]] = func(this, args) {
  "Number toString"
}

let [[%numberToString]] = { [#code : %numberToStringlambda,] }

let [[%NumberProto]] = { [#proto : %ObjectProto,]
  "NEGATIVE_INFINITY" : {#value %neginf, #writable false},
  "toString" : {#value %numberToString, #writable false},
}

let [[%NumberConstructor]] = func(this, args) {
  { [#proto : %NumberProto,] }
}

let [[%NumberGlobalFuncObj]] = { [#code : %NumberConstructor, #proto : %NumberProto,] }

{%NumberProto["constructor" = %NumberGlobalFuncObj]}

let [[%ToBoolean]] = func(x) {
  prim("prim->bool", x)
//  if (prim("stx=", prim("typeof", x), "Object")) {
//    true
//  } else {
//    prim("prim->bool", x)
//  }
}

let [[%instanceof]] = func(o1, o2) {
    if(typeof o1 !== "object") {
        false
    }
    else {
      let (o2prototype = o2["prototype"])
      let (o1proto = prim("get-proto", o1))
      rec (instanceof = func(currproto) {
        if(currproto === null) {
           false
        }
        else {
          if(currproto === o1proto) {
            true
          }
          else {
            instanceof(prim("get-proto", currproto))
          }
        }
      })
      instanceof(o2prototype)
    }
}


let [[%replacelambda]] = func(this, args) {
    undefined
}

let [[%replace]] = { [#code : %replacelambda,] }

let [[%stringToStringlambda]] = func(this, args) {
  prim("get-primval", this)
}

let [[%stringToString]] = {[#code : %stringToStringlambda,]}

let [[%StringProto]] = { [] 
  "toString" : {#value %stringToString, #writable false},
  "replace" : {#value %replace, #writable false} }


let [[%ToObject]] = func (o) {
    label ret : 
    let (t = prim("surface-typeof", o))
    if (t === "object" || t === "function") {
       break ret o
    }
    else { null };
    if (t === "string") {
       break ret
       {[#class: "String", 
         #extensible: true,
         #proto: %StringProto,
         #value: o,]}
    }
    else { null };
    if (t === "number") {
       break ret
       {[#class: "Number",
         #extensible: true,
         #proto: %NumberProto,
         #value: o,]}
    }
    else { null };
    if (t === "boolean") {
       break ret
       {[#class: "Boolean",
         #extensible: true,
         #proto: %BooleanProto,
         #value: o,]}
    }
    else { null };  
    if (t === "function") {
      break ret
      {[#class: "Function",
        #extensible: true,
        #proto: %BooleanProto,
        #value: o,]}
    }
    else { null };
    throw t
}

let [[%objectToStringlambda]] = func(this, args) {
  let (O = %ToObject(this))
  let (class = prim("get-class", O))
  prim("string+", "[object ", prim("string+", class, "]"))
}

let [[%objectToString]] = { [#code : %objectToStringlambda,] }

let [[%valueOflambda]] = func(this, args) {
  %ToObject(this)
}

let [[%valueOf]] = { [#code : %valueOflambda,] }

{ %ObjectProto["toString" = %objectToString];
  %ObjectProto["toString"<#writable> = false];
  %ObjectProto["toString"<#enumerable> = false];

  %ObjectProto["valueOf" = %valueOf];
  %ObjectProto["valueOf"<#writable> = false];
  %ObjectProto["valueOf"<#enumerable> = false] }
  
let [[%ToPrimitiveNum]] = func(obj) {
    label ret :
    let (valueOf = obj["toString"])
    if (prim("typeof", valueOf) === "function") {
        let (str = valueOf(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    let (valueOf = obj["toString"])
    if (prim("typeof", toString) === "function") {
        let (str = toString(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    throw "TypeError exception some day"
}

let [[%ToPrimitiveStr]] = func(obj) {
    label ret :
    let (toString = obj["toString"])
    if (prim("typeof", toString) === "function") {
        let (str = toString(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    let (valueOf = obj["valueOf"])
    if (prim("typeof", valueOf) === "function") {
        let (str = valueOf(obj, {[]})) {
            if (prim("primitive?", str)) {
                break ret str
            }
            else { null }
        }
    };
    throw "TypeError exception some day"
}

let [[%ToPrimitiveHint]] = func(val, hint) {
    let (t = prim("typeof", val))
    if(t === "function" || t === "object") {
        if(hint === "string") {
            %ToPrimitiveStr(val)
        }
        else {
            %ToPrimitiveNum(val)
        }
    }
    else {
        val
    }
}

let [[%ToPrimitive]] = func(val) {
    // TODO exception for date objects
    %ToPrimitiveHint(val, "number")
}

let [[%ToString]] = func(val) {
    prim("prim->str", %ToPrimitiveHint(val, "string"))
}

let [[%StringConstructor]] = func(this, args) {
  let (ps = %ToString(args["0"]))
  { [#value : ps, #proto : %StringProto,] }
}

let [[%StringGlobalFuncObj]] = { [#code : %StringConstructor, #proto : %StringProto,] }

{%StringProto["constructor" = %StringGlobalFuncObj]}

let [[%propEnumlambda]] = func(this, args) {
  let (P = %ToString(args["0"]))
  let (O = %ToObject(this))
  let (desc = O[P])
  if (desc === undefined) {
    false
  } else { 
    O[P<#enumerable>] 
  }
}

let [[%propertyIsEnumerable]] = {[#code : %propEnumlambda,]}

let [[%ToNumber]] = func(val) {
    prim("prim->num", %ToPrimitiveHint(val, "number"))
}

let [[%isNaNlambda]] = func(this, args) {
    args["0"] !== args["0"]
}

// 11.9.3
let [[%EqEq]] = rec (eqeq = func(x1, x2) {
    label ret :
    let (t1 = prim("typeof", x1))
    let (t2 = prim("typeof", x2))
    if(t1 === t2) {
      if(t1 === "undefined") {
          break ret true
      }
      else {
          if(t1 === "null") {
              break ret true }
          else {
              if(t1 === "number") {
                  break ret (x1 === x2) }
              else {
                  if(t1 === "string") {
                      break ret (x1 === x2) }
                  else {
                      if(t1 === "object") {
                          break ret (x1 === x2) }
                      else {
                          throw "[env] Catastrophe---unknown type in ==" }
                  }}}}}
    else {

        if((x1 === undefined && x2 === null) ||
           (x1 === null && x2 === undefined)) {
            break ret true }
        else {
            if(t1 === "number" && t2 === "string") {
                break ret (x1 === prim("prim->num", x2)) }
            else {
                if(t1 === "string" && t2 === "number") {
                    break ret (prim("prim->num", x1) === x2) }
                else {
                    if(t1 === "boolean") {
                        break ret (eqeq(prim("prim->num", x1), x2)) }
                    else {
                        if (t2 === "boolean") {
                            break ret (eqeq(x1, prim("prim->num", x2))) }
                        else {
                            if((t1 === "string" || t1 === "number") &&
                               (t2 === "object")) {
                                break ret eqeq(x1, %ToPrimitive(x2)) }
                            else {
                                if((t2 === "string" || t2 === "number") &&
                                   (t1 === "object")) {
                                    break ret eqeq(%ToPrimitive(x1), x2) }
                                else {
                                    break ret false }
                            }}}}}}}}) eqeq
    

let [[%isNaN]] = { [#code : %isNaNlambda,] }

let [[%printlambda]] = func(o, s) {
    prim("print", %ToString(s["0"]))
}

let [[%print]] = { [#code : %printlambda,] }

let [[%len]] = func(list) {
    rec (inner_len = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                prim("+", 1, inner_len(prim("+", 1, iter)))
            }
            else { iter }
        })
    inner_len(0)
}

let [[%slice]] = func(list, min, max) {
    let (retObj = {[#extensible: true,]})
    rec (inner_slice = func(iter) {
            if(prim("hasOwnProperty", list, prim("prim->str", iter))) {
                retObj[prim("prim->str", iter) = list[prim("prim->str", iter)] ];
                if(prim(">", iter, max)) { undefined }
                else { inner_slice(prim("+", iter, 1)) }
            }
            else { undefined }
        })
    inner_slice(min);
    retObj
}


let [[isDataField]] = func(obj, field) {
    ((obj[field<#value>] !== undefined) ||
     (obj[field<#writable>] !== undefined))
}

let [[isAccessorField]] = func(obj, field) {
    ((obj[field<#setter>] !== undefined) ||
     (obj[field<#getter>] !== undefined))
}

let [[isGenericField]] = func(obj, field) {
    (isDataField(obj, field) === false &&
     isAccessorField(obj, field) === false)
}

let [[isDataDescriptor]] = func(attr-obj) {
    (typeof (attr-obj["value"]) !== "undefined" ||
     typeof (attr-obj["writable"]) !== "undefined")
}

let [[isAccessorDescriptor]] = func(attr-obj) {
    (typeof (attr-obj["set"]) !== "undefined" ||
     typeof (attr-obj["get"]) !== "undefined")
}

let [[isGenericDescriptor]] = func(attr-obj) {
    (isAccessorDescriptor(attr-obj) === false &&
     isDataDescriptor(attr-obj) === false)
}

let [[copy-when-defined]] = func(obj1, obj2, s) {
    if(obj2[s] !== undefined) {
	obj1[s = obj2[s] ]
    }
    else { undefined }
}

let [[copy-data-desc]] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "writable");
    copy-when-defined(obj1, obj2, "value");
    obj1[delete "get"];
    obj1[delete "set"]

}

let [[copy-access-desc]] = func(obj1, obj2) {
    copy-when-defined(obj1, obj2, "configurable");
    copy-when-defined(obj1, obj2, "enumerable");
    copy-when-defined(obj1, obj2, "set");
    copy-when-defined(obj1, obj2, "get");
    obj1[delete "value"];
    obj1[delete "writable"]
}

/* 8.12.9 */
let [[%defineOwnProperty]] = func(obj, field, attr-obj) {
    if (typeof obj !== "object") { throw type_error("defineOwnProperty didn't get object") }
    else {
	let (fstr = %ToString(field))
	if (prim("hasOwnProperty", obj, fstr) === false) {
	    if (prim("is-extensible", obj)) {
		// Do this to open it up for the other properties (will set these last)
		obj[field<#configurable> = true];
		obj[field<#writable> = true];

		{if(isDataDescriptor(attr-obj)) {
		    obj[field<#value> = attr-obj["value"] ];
		    obj[field<#writable> = %ToBoolean(attr-obj["writable"]) ]
		}
		else if(isAccessorDescriptor(attr-obj)) {
		    obj[field<#getter> = attr-obj["get"] ];
		    obj[field<#setter> = attr-obj["set"] ]
		}
		 else { undefined }};

		obj[field<#enumerable> = %ToBoolean(attr-obj["enumerable"]) ];
		obj[field<#configurable> = %ToBoolean(attr-obj["configurable"]) ];
		true
	    }
	    else { throw type_error("(defineOwnProperty) Attempt to add a property to a non-extensible object.") }
	}
	else { /* it definitely has the property */
	    if (obj[field<#configurable>] === false) {
		if (attr-obj["configurable"] === true) {
		    throw type_error("escalating configurable from false to true")
		}
		else {
		    if(attr-obj["enumerable"] ===
		       (obj[field<#enumerable>] === false)) {
			throw type_error("(defineOwnPoperty) Can't change enumerable of a non-configurable property")
		    }
		}
	    };
	    
	    {if ((isDataDescriptor(current-prop)) !== (isDataDescriptor(attr-obj))) {
		if (obj[field<#configurable>] === false) {
		    throw type_error("(defineOwnProperty) Non-configurable property")
		}
		else {
		    if (isDataDescriptor(current)) {
			copy-data-desc(current-obj, attr-obj)
		    }
		    else {
			copy-access-desc(current-obj, attr-obj)
		    }
		}
	    }
	    else if ((isDataDescriptor(current-prop)) && 
		     (isDataDescriptor(attr-obj))) {
		if (current-prop["configurable"] === false) {
		    if (current-prop["writable"] === false) {
			if (attr-obj["writable"] === true) {
			    throw type_error("(defineOwnProperty) Cannot escalate writable from false to true.")
			}
			else {
			    if (attr-obj["value"] !== current-prop["value"]) {
				throw type_error("(defineOwnProperty) Cannot change a non-configurable value")
			    }
			    else { copy-data-desc(current-prop, attr-obj) }
			}
		    }
		    else { copy-data-desc(current-prop, attr-obj) }
		}
		else { copy-data-desc(current-prop, attr-obj) }
	    }
	    else {
		if (current-prop["configurable"] === false) {
		    if (current-prop["set"] !== attr-obj["set"] ||
			current-prop["get"] !== attr-obj["get"]) {
			throw type_error("(defineOwnProperty) Cannot change setter or getter of non-configurable property.")
		    }
		    else { copy-access-desc(current-prop, attr-obj) }
		}
		else { copy-access-desc(current-prop, attr-obj) }
	    }};

	    if(isDataDescriptor(current-prop)) {
		obj[field<#value> = current-prop["value"] ];
		obj[field<#writable> = current-prop["writable"] ]
	    }
	    else if(isAccessorDescriptor(current-prop)) {
		obj[field<#getter> = current-prop["get"] ];
		obj[field<#setter> = current-prop["set"] ]
	    }
	    else { undefined };
	    
	    obj[field<#enumerable> = current-prop["enumerable"] ];
	    obj[field<#configurable> = current-prop["configurable"] ];

	    true
	}
    }
}

let [[%definePropertylambda]] = func(this, args) {
    let (obj = args["0"])
    let (field = args["1"])
    let (propobj = args["2"])
    /* 8.10.5 checks */
    
    if ((typeof obj) !== "object") {
	throw type_error("defineProperty didn't get object")
    }
    else {
	let (attrobj = {[#extensible: true,]})
	let (enumerable = propobj["enumerable"])
	{if ((typeof enumerable) !== "undefined") {
	    attrobj["enumerable" = enumerable]
	}
	 else { attrobj }};

	let (configurable = propobj["configurable"])
	{if ((typeof configurable) !== "undefined") {
	    attrobj["configurable" = configurable]
	}
	 else { attrobj }};
	
	let (writable = propobj["writable"])
	{if ((typeof writable) !== "undefined") {
	    attrobj["writable" = writable]
	}
	 else { attrobj }};
	
	let (value = propobj["value"])
	{if ((typeof value) !== "undefined") {
	    attrobj["value" = value]
	}
	 else { attrobj }};
	
	let (get = propobj["get"])
	{if ((typeof get) !== "undefined" && 
	     (prim("surface-typeof", get) !== "function")) {
	    throw type_error("defineProperty given a non-function getter")
	}
	 else {
	     attrobj["get" = get]
	 }};
	
	let (set = propobj["set"])
	{if (typeof set !== "undefined" && 
	     (prim("surface-typeof", set) !== "function")) {
	    throw type_error("defineProperty given a non-function setter")
	}
	 else {
	     attrobj["set" = set]
	 }};

	// 8.10.5, step 9
	if ((isDataDescriptor(attrobj)) && 
            (isAccessorDescriptor(attrobj))) {
            throw "TypeError --- both accessor and data"
//	    throw type_error("The attributes given to defineProperty were inconsistent")
	}
	else {
	    %defineOwnProperty(obj, field, attrobj)
	}
    }	   
}

let [[%defineProperty]] = { [#code : %definePropertylambda,] }


 let [[%ObjectConstructor]] = func(this, args) {
  let (calledAsFunction = this === %global)
  let (hasArg = prim(">", args["length"], 0))
  let (notNull = prim("!", args["0"] === null))
  let (notUndefined = prim ("!", args["0"] === undefined))
  let (shouldReturnEarly =
    calledAsFunction && hasArg && notNull && notUndefined)
  let (defaultRtn = { [#proto : %ObjectProto,] })
  if (shouldReturnEarly) {
    %ToObject(args["0"])
  } else {
    if (hasArg) {
      let (argtype = prim("typeof", args["0"]))
      let (isArgObject = argtype === "object" || argtype === "function")
      let (isArgSomething = argtype === "boolean" ||
        argtype === "string" || argtype === "number")
      if (isArgObject) { args["0"] } else {
        if (isArgSomething) { %ToObject(args["0"]) } else { defaultRtn }
      }
    } else {
      defaultRtn
    }
  }
}

 let [[%ObjectGlobalFuncObj]] = 
  { [#code : %ObjectConstructor, #proto : %ObjectProto,] 
    "prototype" : {#value %ObjectProto, #writable false},
    "length" : {#value 1, #writable false},
  }

 {%ObjectProto["constructor" = %ObjectGlobalFuncObj];
  %ObjectProto["constructor"<#enumerable> = false]}


let [[%calllambda]] = func(this, args) {
    this(args["0"], %slice(args, 1, %len(args)))
}

let [[%call]] = { [#code : %calllambda,] }

let [[%functionToStringlambda]] = func(this, args) {
  "function ToString"
}

let [[%functionToString]] = { [#code : %functionToStringlambda,] }

let [[%FunctionProto]] = { [#proto: %ObjectGlobalFuncObj,]
  "toString" : {#value %functionToString, #writable false},
  "call" : {#value %call, #writable false} }

let [[%FunctionConstructor]] = func(this, args) {
  let (argCount = args["length"])
  rec (formArgString = func(n, result) {
    if (n === argCount) {
      result
    } else {
      let (currentArg = %ToString(args[prim("prim->str", n)]))
      let (next = 
        if (n === prim("-", argCount, 1)) { 
          prim("+", result, currentArg)
        } else {
          prim("+", prim("+", result, currentArg), ",")
        })
      formArgString(prim("+", n, 1), next)
    }
  })
  let (body = 
    if (argCount === 0) { "" } else {
      args[prim("prim->str", prim("-", argCount, 1))]
    })
  let (P = if (argCount === 0 || argCount === 1) { "" }
    else { formArgString(0, "") })
  let (placeHolder = func(this, args) {
    "new Function(...) placeholder"
  })
  { [#code : placeHolder, #proto : %FunctionProto,] }
}

let [[%FunctionGlobalFuncObj]] = 
  { [#code : %FunctionConstructor, #proto : %FunctionProto,] }

{%FunctionProto["constructor" = %FunctionGlobalFuncObj]}

let [[%pushlambda]] = func(this, args) {
  this[ prim("prim->str", this["length"]) = args["0"] ];
  this[ "length" = prim("+", this["length"], 1) ]
}

let [[%push]] = { [#code : %pushlambda,] }


let [[%sortlambda]] = func(this, args) {
    undefined
}

let [[%sort]] = { [#code : %sortlambda,] }

let [[%joinlambda]] = func(this, args) {
    let (list = this)
    let (separator = 
      if (prim("hasOwnProperty", args, prim("prim->str", 0))) {
        args[prim("prim->str", 0)]
      } else {
        ","
      })
    rec (inner_join = func(n, result) {
      if (prim("<=", n, 0)) {
        prim("string+", %ToString(list[prim("prim->str", n)]), result) 
      } else {
        let (element = %ToString(list[prim("prim->str", n)]))
        let (next = 
        prim("string+", separator, prim("string+", element, result)))
        inner_join(prim("-", n, 1), next)
      }
    })
    let(R = if((this["0"] === undefined) || (this["0"] === null)) {
      ""
    } else { %ToString(list["0"]) })
    let (start = prim("-", prim("prim->num", this["length"]), 1))
    inner_join(start, "")
}

let [[%join]] = { [#code : %joinlambda,] }

let [[%arrayToStringlambda]] = func(this, args) {
  undefined
}

let [[%arrayToString]] = { [#code : %arrayToStringlambda,] }

let [[%ArrayProto]] = { [] 
  "toString" : {#value %arrayToString, #writable false},
  "push" : {#value %push, #writable false}, 
  "sort" : {#value %sort, #writable false},
  "join" : {#value %join, #writable false} }

let [[%ArrayConstructor]] = func(this, args) {
  let (rtnobj = { [#proto : %ArrayProto,] "length" : {#value 0, #writable true}, })
  rec (init = func(n) {
    rtnobj[ prim("prim->str", n) = args[prim("prim->str", n)] ];
    if (prim(">", n, 0)) {
      init(prim("-", n, 1))
    }
  })
  init(args["length"]);
  rtnobj["length" = args["length"] ];
  rtnobj
}

let [[%ArrayGlobalFuncObj]] = { [#code : %ArrayConstructor, #proto : %ArrayProto,] }

let [[%getCurrentUTC]] = func() { 0 } // TODO: implement

let [[%parse]] = func(v) { 0 } // TODO: implement

let [[%TimeClip]] = func(v) { 0 } // TODO: implement

let [[%ToInteger]] = func(i) { 0 } // TODO: implement

let [[%MakeDate]] = func(day, time) { 0 } // TODO: implement

let [[%MakeDay]] = func(yr, mt, dt) { 0 } // TODO: implement

let [[%MakeTime]] = func(h, min, s, milli) { 0 } // TODO: implement

let [[%UTC]] = func(v) { 0 } // TODO: implement

let [[%getYearlambda]] = func(this, args) { 78 } // TODO: implement

let [[%getYear]] = { [#code : %getYearlambda,] }

let [[%getMonthlambda]] = func(this, args) { 3 } // TODO: implement

let [[%getMonth]] = { [#code: %getMonthlambda,] }

let [[%DateProto]] = { 
  [#proto : %ObjectProto,]
  "getYear" : {#value %getYear, #writable false},
  "getMonth": {#value %getMonth, #writable false},
}

let [[%DateConstructor]] = func(this, args) {
  let (calledAsFunction = this === %global)
  let (nargs = args["length"])
  if (nargs === "0") {
    let (v = %getCurrentUTC())
    { [#proto : %DateProto, #class : "Date", #extensible : true, #value : v,] }
  } else {
    if (nargs === "1") {
      let (v = %ToPrimitive(args["0"]))
      let (V =
        if (prim("typeof", v) === "string") { %parse(v) } else { %ToNumber(v) })
      let (clipped = %TimeClip(V))
      { [#proto : %DateProto, #class : "Date", #extensible : true, #value : clipped,] }
    } else {
      let (y = %ToNumber(args["0"]))
      let (m = %ToNumber(args["1"]))
      let (dt = if (args["2"] === undefined) { 1 } else { %ToNumber(args["2"]) })
      let (h = if (args["3"] === undefined) { 0 } else { %ToNumber(args["3"]) })
      let (min = if (args["4"] === undefined) { 0 } else { %ToNumber(args["4"]) })
      let (s = if (args["5"] === undefined) { 0 } else { %ToNumber(args["5"]) })
      let (milli = if (args["6"] === undefined) { 0 } else { %ToNumber(args["6"]) })
      let (yr = 
        let (tiy = %ToInteger(y))
        let (rangecond1 = prim("<", 0, tiy) || 0 === tiy)
        let (rangecond2 = prim("<", tiy, 99) || tiy === 99)
        if (y !== y && rangecond1 && rangecond2) {
          prim("+", 1900, tiy) } else { y })
      let (finalDate = %MakeDate(%MakeDay(yr, m, dt), %MakeTime(h, min, s, milli)))
      let (primval = %UTC(%TimeClip(finalDate)))
      { [#proto : %DateProto, #class : "Date", #extensible : true, #value : primval,] }
    }
  }
}

let [[%DateGlobalFuncObj]] = { [#code : %DateConstructor, #proto : %DateProto,] }


let [[%testlambda]] = func(this, args) {
  prim("print", "test")
}

let [[%test]] = { [#code : %testlambda,] }

let [[%RegexpProto]] = { []
  "test" : {#value %test, #writable false} }


let [[%parseIntlambda]] = func(n) {
  undefined
}

let [[%parseInt]] = { [#code : %parseIntlambda,] }

let [[%explambda]] = func() {
  undefined
}

let [[%exp]] = { [#code : %explambda,] }

let [[%Math]] = { []
  "exp" : {#value %exp, #writable false} }
  

let [[%PrimAdd]] = func(l, r) {
    let (l = %ToPrimitive(l))
    let (r = %ToPrimitive(r))
  if (prim("stx=", prim("typeof", l), "string")) {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else if (prim("stx=", prim("typeof", r), "string")) {
    let (lstr = prim("prim->str", l))
    let (rstr = prim("prim->str", r))
    prim("string+", lstr, rstr)
  } else {
    let (lnum = prim("prim->num", l))
    let (rnum = prim("prim->num", r))
    prim("+", lnum, rnum)
  }
}

let [[%PrimSub]] = func(l, r) {
    let (l = %ToPrimitiveHint(l, "number"))
    let (r = %ToPrimitiveHint(r, "number"))
    prim("-", l, r)
}

let [[%TETSlambda]] = func(this, args) {
  "TypeError"
}

let [[%TEToString]] = { [#code : %TETSlambda,] }

let [[%TypeErrorProto]] = { [#proto : %ObjectProto,] 
  "toString" : {#value %TEToString, #writable false} }

let [[%TypeErrorConstructor]] = func(this, args) {
  { [#proto : %TypeErrorProto,] }
}

let [[%TypeErrorGlobalFuncObj]] = 
  { [#code : %TypeErrorConstructor, #proto : %TypeErrorProto,] 
    "prototype" : {#value %TypeErrorProto, #writable false} }

{%TypeErrorProto["constructor" = %TypeErrorGlobalFuncObj]}

let [[%ThrowTypeError]] = {
    [ #code : func(this, args) {
        throw { [#proto : %TypeErrorProto,] }
      },]}

{
  %global["print" = %print];
  %global["Array" = %ArrayGlobalFuncObj];
  %global["String" = %StringGlobalFuncObj];
  %global["Object" = %ObjectGlobalFuncObj];
  %global["Number" = %NumberGlobalFuncObj];
  %global["Boolean" = %BooleanGlobalFuncObj];
  %global["Date" = %DateGlobalFuncObj];
  %global["Function" = %FunctionGlobalFuncObj];
  %global["isNaN" = %isNaN];
  %global["Math" = %Math];
  %global["parseInt" = %parseInt];
  %global["TypeError" = %TypeErrorGlobalFuncObj];

  %ObjectProto["propertyIsEnumerable" = %propertyIsEnumerable];
  %ObjectProto["propertyIsEnumerable"<#enumerable> = false];

  %ObjectProto["defineProperty" = %defineProperty];
  %ObjectProto["defineProperty"<#enumerable> = false]
}

//let [[%global]] = { [] 
//  "print" : {#value %print, #writable false}, 
//  "Array" : {#value %ArrayGlobalFuncObj, #writable false},
//  "String" : {#value %StringGlobalFuncObj, #writable false},
//  "Object" : {#value %ObjectGlobalFuncObj, #writable false},
//  "Number" : {#value %NumberGlobalFuncObj, #writable false},
//  "Boolean" : {#value %BooleanGlobalFuncObj, #writable false},
//  "Function" : {#value %FunctionProto, #writable false},
//  "isNaN" : {#value %isNaN, #writable false },
//  "Math" : {#value %Math, #writable false },
//  "parseInt" : {#value %parseInt, #writable false}
//}

let [[%context]] = %global

let [[%evallambda]] = func(this, args) {
    @eval(args["0"])
}

let [[%eval]] = { [#code : %evallambda,] }

{%global["eval" = %eval];
 %global["eval"<#enumerable> = false]}
